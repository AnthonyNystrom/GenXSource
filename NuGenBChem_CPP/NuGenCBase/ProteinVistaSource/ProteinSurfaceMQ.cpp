//	(c) 2000-2002 J. Gans (jdg9@cornell.edu), Shalloway Lab, 
//	Cornell University. You can modify and freely distribute 
//	this code, but please keep this header intact.

// Much of the code below is based on the 
// "Marching Cubes Example Program 
// by Cory Bloyd (corysama@yahoo.com)
//
// A simple, portable and complete implementation of the Marching Cubes
// and Marching Tetrahedrons algorithms in a single source file.
// There are many ways that this code could be made faster, but the 
// intent is for the code to be easy to understand.
//
// For a description of the algorithm go to
// http://astronomy.swin.edu.au/pbourke/modelling/polygonise/
//
// This code is public domain."
//

#include "stdafx.h"
#include "ProteinVista.h"
#include "ProteinVistaView.h"

#include "ProteinVistaRenderer.h"
#include "pdb.h"
#include <math.h>
#include "Interface.h"
#include <set>
#include <algorithm>

#include "RenderSurfaceArray.h"
#include "RenderSurfaceList.h"
#include "Interface.h"

using namespace RenderSurfaceList;
using namespace RenderSurfaceArray;

#include "ProteinSurfaceMQ.h"
#include "ColorScheme.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define	 SURFACE_QUALITY	60

#pragma region TABLE

#define INDEX_X		0
#define INDEX_Y		1
#define INDEX_Z		2

// Linear algebra macros:
// A.B (inner product)
#define		DOT(A, B)	(A[INDEX_X]*B[INDEX_X] + A[INDEX_Y]*B[INDEX_Y] + A[INDEX_Z]*B[INDEX_Z])

// AXB (outer product)
#define		CROSS(A,B,C) A[INDEX_X] = B[INDEX_Y]*C[INDEX_Z] - B[INDEX_Z]*C[INDEX_Y]; \
						 A[INDEX_Y] = B[INDEX_Z]*C[INDEX_X] - B[INDEX_X]*C[INDEX_Z]; \
						 A[INDEX_Z] = B[INDEX_X]*C[INDEX_Y] - B[INDEX_Y]*C[INDEX_X]

// ******* Atom box parameters *******
// These values obtained by finding minimum box length that didn't cause
// surface artifacts. They still need some fine tuning
//#define	BOX_LENGTH		1.9f
//#define	MAX_NUM_BOX		100.0f
//#define	MAX_LENGTH		(BOX_LENGTH*MAX_NUM_BOX)

#define	VERTEX_BOX_LENGTH		0.5f
#define	VERTEX_MAX_NUM_BOX		200.0f
#define	VERTEX_MAX_LENGTH		(VERTEX_BOX_LENGTH*VERTEX_MAX_NUM_BOX)

//	#define	MAX_MESH_SIZE	1.75f
#define	MAX_MESH_SIZE	4.0f
#define	MIN_MESH_SIZE	1.0f

// Which parameterization of the molecular surface should we use?
#define	USE_R6		// A "softer" surface

//a2fVertexOffset lists the positions, relative to vertex0, of each of the 8 vertices of a cube
static const float a2fVertexOffset[8][3] =
{
        {0.0, 0.0, 0.0},{1.0, 0.0, 0.0},{1.0, 1.0, 0.0},{0.0, 1.0, 0.0},
        {0.0, 0.0, 1.0},{1.0, 0.0, 1.0},{1.0, 1.0, 1.0},{0.0, 1.0, 1.0}
};

//a2iEdgeConnection lists the index of the endpoint vertices for each of the 12 edges of the cube
static const int a2iEdgeConnection[12][2] = 
{
        {0,1}, {1,2}, {2,3}, {3,0},
        {4,5}, {5,6}, {6,7}, {7,4},
        {0,4}, {1,5}, {2,6}, {3,7}
};

//a2fEdgeDirection lists the direction vector (vertex1-vertex0) for each edge in the cube
static const float a2fEdgeDirection[12][3] =
{
        {1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
        {1.0, 0.0, 0.0},{0.0, 1.0, 0.0},{-1.0, 0.0, 0.0},{0.0, -1.0, 0.0},
        {0.0, 0.0, 1.0},{0.0, 0.0, 1.0},{ 0.0, 0.0, 1.0},{0.0,  0.0, 1.0}
};

//  For each of the possible vertex states listed in aiCubeEdgeFlags there is a specific triangulation
//  of the edge intersection points.  a2iTriangleConnectionTable lists all of them in the form of
//  0-5 edge triples with the list terminated by the invalid value -1.
//  For example: a2iTriangleConnectionTable[3] list the 2 triangles formed when corner[0] 
//  and corner[1] are inside of the surface, but the rest of the cube is not.
//
//  I found this table in an example program someone wrote long ago.  It was probably generated by hand

int a2iTriangleConnectionTable[256][16] =  
{
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
        {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
        {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
        {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
        {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
        {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
        {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
        {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
        {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
        {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
        {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
        {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
        {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
        {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
        {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
        {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
        {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
        {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
        {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
        {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
        {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
        {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
        {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
        {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
        {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
        {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
        {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
        {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
        {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
        {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
        {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
        {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
        {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
        {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
        {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
        {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
        {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
        {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
        {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
        {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
        {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
        {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
        {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
        {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
        {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
        {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
        {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
        {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
        {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
        {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
        {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
        {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
        {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
        {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
        {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
        {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
        {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
        {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
        {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
        {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
        {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
        {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
        {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
        {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
        {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
        {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
        {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
        {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
        {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
        {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
        {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
        {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
        {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
        {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
        {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
        {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
        {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
        {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
        {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
        {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
        {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
        {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
        {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
        {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
        {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
        {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
        {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
        {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
        {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
        {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
        {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
        {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
        {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
        {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
        {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
        {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
        {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
        {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
        {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
        {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
        {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
        {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
        {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
        {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
        {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
        {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
        {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
        {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
        {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
        {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
        {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
        {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
        {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
        {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
        {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
        {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
        {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
        {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
        {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
        {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
        {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
        {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
        {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
        {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
        {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
        {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
        {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
        {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
        {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
        {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
        {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
        {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
        {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
        {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
        {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
        {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
        {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
        {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
        {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
        {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
        {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
        {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
        {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
        {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
        {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
        {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
        {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
        {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
        {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
        {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
        {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
        {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
        {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
        {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
        {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
        {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
        {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
        {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
        {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
        {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
        {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
        {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
        {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
        {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
        {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
        {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
        {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
        {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
        {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
        {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
        {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
        {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
        {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
        {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
        {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
        {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
        {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
        {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
        {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
        {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

// For any edge, if one vertex is inside of the surface and the other is 
// outside of the surface then the edge intersects the surface
// For each of the 8 vertices of the cube can be two possible states : 
// either inside or outside of the surface
// For any cube the are 2^8=256 possible sets of vertex states
// This table lists the edges intersected by the surface for all 256 
// possible vertex states. There are 12 edges.  For each entry in the table, 
// if edge #n is intersected, then bit #n is set to 1

int aiCubeEdgeFlags[256]=
{
        0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 
        0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 
        0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 
        0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 
        0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 
        0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 
        0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 
        0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 
        0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 
        0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 
        0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 
        0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, 
        0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, 
        0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, 
        0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, 
        0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x000
};

#pragma endregion

BOOL CProteinSurfaceMQ::BuildSurface(CSTLArrayAtom & arrayAtom )
{
	float x, y, z;
	int i, j, k;

	// Which structure are we generating a surface for?
	traj_index = -1;

	BuildAtomBox();

	float xmin = molMin[INDEX_X], 
			ymin = molMin[INDEX_Y],
			zmin = molMin[INDEX_Z];

	// Build the cube box
	cubeSize[INDEX_X] = (int)((molMax[INDEX_X] - xmin)/meshSize) + 1;
	cubeSize[INDEX_Y] = (int)((molMax[INDEX_Y] - ymin)/meshSize) + 1;
	cubeSize[INDEX_Z] = (int)((molMax[INDEX_Z] - zmin)/meshSize) + 1;
	
	cubeXY = cubeSize[INDEX_X]*cubeSize[INDEX_Y];

	cubeBox.Alloc(cubeSize[INDEX_X]*cubeSize[INDEX_Y]*cubeSize[INDEX_Z]);

	// Keep the user informed
	long iProgress =GetMainActiveView()->InitProgress(200);

	//CMainFrame *pFrame = (CMainFrame*)AfxGetApp()->m_pMainWnd;
	const int step_every = 10;
	int max_count = 2*cubeSize[INDEX_Z] - 1;
	int progress_counter = 0;

	// Clean up the triangle list
	while(!triangleList.IsEmpty()){
		triangleList.Pop();
	}

	for(z = zmin, i = 0; i < cubeSize[INDEX_Z]; z += meshSize, i++){
		for(y = ymin, j = 0; j < cubeSize[INDEX_Y]; y += meshSize, j++){
			for(x = xmin, k = 0; k < cubeSize[INDEX_X]; x += meshSize, k++){
				cubeBox[i*cubeXY + j*cubeSize[INDEX_X] + k] = ScalarField(x, y, z);
			}
		}

		progress_counter ++;
		if((progress_counter%step_every == 0)  )
		{
			// Advance the progress bar
			long count = (100*progress_counter)/max_count;
			GetMainActiveView()->SetProgress(count, iProgress);
			PumpMessage();
		}
	}


	// Don't check the outer edges of the "box" of scalar field values.
	xmin += meshSize;
	ymin += meshSize;
	zmin += meshSize;

	int max_x_index = cubeSize[INDEX_X] - 1;
	int max_y_index = cubeSize[INDEX_Y] - 1;
	int max_z_index = cubeSize[INDEX_Z] - 1;

	for(z = zmin, i = 1; i < max_z_index ; z += meshSize, i++){
		for(y = ymin, j = 1; j < max_y_index; y += meshSize, j++){
			for(x = xmin, k = 1; k < max_x_index; x += meshSize, k++){
				vMarchCube(x, y, z, k, j, i, meshSize);
			}
		}

		progress_counter ++;
		if((progress_counter%step_every == 0) )
		{
			// Advance the progress bar
			long count = (100*progress_counter)/max_count;
			GetMainActiveView()->SetProgress(count, iProgress);

			PumpMessage();
		}
	}

	GetMainActiveView()->EndProgress(iProgress);

	//  ** We now have a list of triangle verticies. **

	// Convert this list into a non-redundant array of verticies 
	// (and remove "runt" verticies). After we compute this list, 
	// we will compute the color index of each vertex.
	BuildVertexArray();

	DeleteAtomBox();

	cubeBox.Alloc(0);	

	// Set the valid surface flag
	validSurface = TRUE;

	return TRUE;
}

//vMarchCube1 performs the Marching Cubes algorithm on a single cube
void CProteinSurfaceMQ::vMarchCube(float fX, float fY, float fZ, 
							  int xIndex, int yIndex, int zIndex, float fScale)
{
	int iFlagIndex, iEdgeFlags;
	float fOffset;
	float afCubeValue[8];
	float asEdgeVertex[12][3];

	//Make a local copy of the values at the cube's corners
	afCubeValue[0] = cubeBox[zIndex*cubeXY + yIndex*cubeSize[INDEX_X] + xIndex];
	afCubeValue[1] = cubeBox[zIndex*cubeXY + yIndex*cubeSize[INDEX_X] + xIndex + 1];
	afCubeValue[2] = cubeBox[zIndex*cubeXY + (yIndex + 1)*cubeSize[INDEX_X] + xIndex + 1];
	afCubeValue[3] = cubeBox[zIndex*cubeXY + (yIndex + 1)*cubeSize[INDEX_X] + xIndex];
	afCubeValue[4] = cubeBox[(zIndex + 1)*cubeXY + yIndex*cubeSize[INDEX_X] + xIndex];
	afCubeValue[5] = cubeBox[(zIndex + 1)*cubeXY + yIndex*cubeSize[INDEX_X] + xIndex + 1];
	afCubeValue[6] = cubeBox[(zIndex + 1)*cubeXY + (yIndex + 1)*cubeSize[INDEX_X] + xIndex + 1];
	afCubeValue[7] = cubeBox[(zIndex + 1)*cubeXY + (yIndex + 1)*cubeSize[INDEX_X] + xIndex];

	//Find which vertices are inside of the surface and which are outside
	iFlagIndex = 0;

	if(afCubeValue[0] <= fTargetValue)
		// No need to use a bitwise operator for the first
		// bit.
		iFlagIndex = 1;

	if(afCubeValue[1] <= fTargetValue) 
		iFlagIndex |= 2;

	if(afCubeValue[2] <= fTargetValue) 
		iFlagIndex |= 4;

	if(afCubeValue[3] <= fTargetValue) 
		iFlagIndex |= 8;

	if(afCubeValue[4] <= fTargetValue) 
		iFlagIndex |= 16;

	if(afCubeValue[5] <= fTargetValue) 
		iFlagIndex |= 32;

	if(afCubeValue[6] <= fTargetValue) 
		iFlagIndex |= 64;

	if(afCubeValue[7] <= fTargetValue) 
		iFlagIndex |= 128;

	//Find which edges are intersected by the surface
	iEdgeFlags = aiCubeEdgeFlags[iFlagIndex];

	//If the cube is entirely inside or outside of the surface, then there will be no intersections
	if(iEdgeFlags == 0) {
		return;
	}

	// Find the point of intersection of the surface with each edge.
	// Then find the normal to the surface at those points
	// if there is an intersection on the given edge.
	if(iEdgeFlags & 1){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[0][0] ], 
			afCubeValue[ a2iEdgeConnection[0][1] ], 
			fTargetValue);
		
		asEdgeVertex[0][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[0][0] ][0]  +  
			fOffset * a2fEdgeDirection[0][0]) * fScale;
		asEdgeVertex[0][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[0][0] ][1]  +  
			fOffset * a2fEdgeDirection[0][1]) * fScale;
		asEdgeVertex[0][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[0][0] ][2]  +  
			fOffset * a2fEdgeDirection[0][2]) * fScale;
	}

	if(iEdgeFlags & 2){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[1][0] ], 
			afCubeValue[ a2iEdgeConnection[1][1] ], 
			fTargetValue);
		
		asEdgeVertex[1][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[1][0] ][0]  +  
			fOffset * a2fEdgeDirection[1][0]) * fScale;
		asEdgeVertex[1][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[1][0] ][1]  +  
			fOffset * a2fEdgeDirection[1][1]) * fScale;
		asEdgeVertex[1][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[1][0] ][2]  +  
			fOffset * a2fEdgeDirection[1][2]) * fScale;
	}

	if(iEdgeFlags & 4){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[2][0] ], 
			afCubeValue[ a2iEdgeConnection[2][1] ], 
			fTargetValue);
		
		asEdgeVertex[2][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[2][0] ][0]  +  
			fOffset * a2fEdgeDirection[2][0]) * fScale;
		asEdgeVertex[2][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[2][0] ][1]  +  
			fOffset * a2fEdgeDirection[2][1]) * fScale;
		asEdgeVertex[2][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[2][0] ][2]  +  
			fOffset * a2fEdgeDirection[2][2]) * fScale;
	}

	if(iEdgeFlags & 8){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[3][0] ], 
			afCubeValue[ a2iEdgeConnection[3][1] ], 
			fTargetValue);
		
		asEdgeVertex[3][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[3][0] ][0]  +  
			fOffset * a2fEdgeDirection[3][0]) * fScale;
		asEdgeVertex[3][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[3][0] ][1]  +  
			fOffset * a2fEdgeDirection[3][1]) * fScale;
		asEdgeVertex[3][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[3][0] ][2]  +  
			fOffset * a2fEdgeDirection[3][2]) * fScale;
	}

	if(iEdgeFlags & 16){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[4][0] ], 
			afCubeValue[ a2iEdgeConnection[4][1] ], 
			fTargetValue);
		
		asEdgeVertex[4][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[4][0] ][0]  +  
			fOffset * a2fEdgeDirection[4][0]) * fScale;
		asEdgeVertex[4][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[4][0] ][1]  +  
			fOffset * a2fEdgeDirection[4][1]) * fScale;
		asEdgeVertex[4][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[4][0] ][2]  +  
			fOffset * a2fEdgeDirection[4][2]) * fScale;
	}

	if(iEdgeFlags & 32){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[5][0] ], 
			afCubeValue[ a2iEdgeConnection[5][1] ], 
			fTargetValue);
		
		asEdgeVertex[5][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[5][0] ][0]  +  
			fOffset * a2fEdgeDirection[5][0]) * fScale;
		asEdgeVertex[5][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[5][0] ][1]  +  
			fOffset * a2fEdgeDirection[5][1]) * fScale;
		asEdgeVertex[5][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[5][0] ][2]  +  
			fOffset * a2fEdgeDirection[5][2]) * fScale;
	}

	if(iEdgeFlags & 64){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[6][0] ], 
			afCubeValue[ a2iEdgeConnection[6][1] ], 
			fTargetValue);
		
		asEdgeVertex[6][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[6][0] ][0]  +  
			fOffset * a2fEdgeDirection[6][0]) * fScale;
		asEdgeVertex[6][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[6][0] ][1]  +  
			fOffset * a2fEdgeDirection[6][1]) * fScale;
		asEdgeVertex[6][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[6][0] ][2]  +  
			fOffset * a2fEdgeDirection[6][2]) * fScale;
	}

	if(iEdgeFlags & 128){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[7][0] ], 
			afCubeValue[ a2iEdgeConnection[7][1] ], 
			fTargetValue);
		
		asEdgeVertex[7][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[7][0] ][0]  +  
			fOffset * a2fEdgeDirection[7][0]) * fScale;
		asEdgeVertex[7][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[7][0] ][1]  +  
			fOffset * a2fEdgeDirection[7][1]) * fScale;
		asEdgeVertex[7][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[7][0] ][2]  +  
			fOffset * a2fEdgeDirection[7][2]) * fScale;
	}

	if(iEdgeFlags & 256){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[8][0] ], 
			afCubeValue[ a2iEdgeConnection[8][1] ], 
			fTargetValue);
		
		asEdgeVertex[8][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[8][0] ][0]  +  
			fOffset * a2fEdgeDirection[8][0]) * fScale;
		asEdgeVertex[8][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[8][0] ][1]  +  
			fOffset * a2fEdgeDirection[8][1]) * fScale;
		asEdgeVertex[8][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[8][0] ][2]  +  
			fOffset * a2fEdgeDirection[8][2]) * fScale;
	}

	if(iEdgeFlags & 512){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[9][0] ], 
			afCubeValue[ a2iEdgeConnection[9][1] ], 
			fTargetValue);
		
		asEdgeVertex[9][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[9][0] ][0]  +  
			fOffset * a2fEdgeDirection[9][0]) * fScale;
		asEdgeVertex[9][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[9][0] ][1]  +  
			fOffset * a2fEdgeDirection[9][1]) * fScale;
		asEdgeVertex[9][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[9][0] ][2]  +  
			fOffset * a2fEdgeDirection[9][2]) * fScale;
	}

	if(iEdgeFlags & 1024){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[10][0] ], 
			afCubeValue[ a2iEdgeConnection[10][1] ], 
			fTargetValue);
		
		asEdgeVertex[10][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[10][0] ][0]  +  
			fOffset * a2fEdgeDirection[10][0]) * fScale;
		asEdgeVertex[10][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[10][0] ][1]  +  
			fOffset * a2fEdgeDirection[10][1]) * fScale;
		asEdgeVertex[10][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[10][0] ][2]  +  
			fOffset * a2fEdgeDirection[10][2]) * fScale;
	}

	if(iEdgeFlags & 2048){
		fOffset = fGetOffset(afCubeValue[ a2iEdgeConnection[11][0] ], 
			afCubeValue[ a2iEdgeConnection[11][1] ], 
			fTargetValue);
		
		asEdgeVertex[11][INDEX_X] = fX + (a2fVertexOffset[ a2iEdgeConnection[11][0] ][0]  +  
			fOffset * a2fEdgeDirection[11][0]) * fScale;
		asEdgeVertex[11][INDEX_Y] = fY + (a2fVertexOffset[ a2iEdgeConnection[11][0] ][1]  +  
			fOffset * a2fEdgeDirection[11][1]) * fScale;
		asEdgeVertex[11][INDEX_Z] = fZ + (a2fVertexOffset[ a2iEdgeConnection[11][0] ][2]  +  
			fOffset * a2fEdgeDirection[11][2]) * fScale;
	}

	// Save the triangles that were found.  There can be up to five per cube
	Triangle tmpTriangle;

	if(a2iTriangleConnectionTable[iFlagIndex][0] >= 0){
		tmpTriangle.SetVertex(0, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][0]]);
		tmpTriangle.SetVertex(1, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][1]]);
		tmpTriangle.SetVertex(2, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][2]]);

		// Save the triangle
		triangleList.PushTop(tmpTriangle);
	}

	if(a2iTriangleConnectionTable[iFlagIndex][3] >= 0){
		tmpTriangle.SetVertex(0, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][3]]);
		tmpTriangle.SetVertex(1, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][4]]);
		tmpTriangle.SetVertex(2, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][5]]);

		// Save the triangle
		triangleList.PushTop(tmpTriangle);
	}

	if(a2iTriangleConnectionTable[iFlagIndex][6] >= 0){
		tmpTriangle.SetVertex(0, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][6]]);
		tmpTriangle.SetVertex(1, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][7]]);
		tmpTriangle.SetVertex(2, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][8]]);

		// Save the triangle
		triangleList.PushTop(tmpTriangle);
	}

	if(a2iTriangleConnectionTable[iFlagIndex][9] >= 0){
		tmpTriangle.SetVertex(0, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][9]]);
		tmpTriangle.SetVertex(1, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][10]]);
		tmpTriangle.SetVertex(2, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][11]]);

		// Save the triangle
		triangleList.PushTop(tmpTriangle);
	}

	if(a2iTriangleConnectionTable[iFlagIndex][12] >= 0){
		tmpTriangle.SetVertex(0, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][12]]);
		tmpTriangle.SetVertex(1, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][13]]);
		tmpTriangle.SetVertex(2, asEdgeVertex[a2iTriangleConnectionTable[iFlagIndex][14]]);

		// Save the triangle
		triangleList.PushTop(tmpTriangle);
	}
}

float CProteinSurfaceMQ::ScalarFieldHeuristic(float fX, float fY, float fZ)
{
	float fResult = 0.0f;

	int boxIndex = numBox[INDEX_X]*((int)((fZ - molMin[INDEX_Z]) * invBoxSize[INDEX_Z])*numBox[INDEX_Y] + 
							  (int)((fY - molMin[INDEX_Y]) * invBoxSize[INDEX_Y]))
				   + (int)((fX - molMin[INDEX_X]) * invBoxSize[INDEX_X]);

	// Don't evaluate points outside the box!
	if((boxIndex < 0) || (boxIndex >= totb)){
		return fResult;
	}

	int tmpIndex;
	float r2;
	int index_x, index_y, index_z;

	// Check the current box and all neighbooring boxes too
	for(index_z = -1;index_z <= 1;index_z ++){
		for(index_y = -1;index_y <= 1;index_y ++){
			for(index_x = -1;index_x <= 1;index_x ++){
				tmpIndex = boxIndex + index_z*xytotb + index_y*numBox[INDEX_X] + index_x;

				// Are we out of bounds?
				if((tmpIndex < 0) || (tmpIndex >= totb))
					continue;

				// Get the list of atoms in this box
				listRender<int>* currBox = atomBox[tmpIndex];
				
				// Are there any atms in this box?
				if(currBox == NULL)
					// No atoms in this box!
					continue;
				
				ListIterator<int> next((*currBox));
				int *ptr;

				while(ptr = next()){
					CAtom &currAtom = *(m_arrayAtom[*ptr]);

					r2 = currAtom.m_fRadius + probeSphere;

					D3DXVECTOR3 vecTemp;
					vecTemp.x = currAtom.m_pos.x-fX;
					vecTemp.y = currAtom.m_pos.y-fY;
					vecTemp.z = currAtom.m_pos.z-fZ;
					
					r2 = (vecTemp.x*vecTemp.x + vecTemp.y*vecTemp.y + vecTemp.z*vecTemp.z)/(r2*r2);
					
					fResult += 1.0f/(1.0f + r2*r2*r2);

					// If fResult is large enough (i.e. fResult > targetValueCutOff), 
					// don't bother summing over more atoms in this box
					// (i.e. this grid element will not longer contribute to the shape of 
					// the iso-surface).
					if(fResult > targetValueCutOff)
						return fResult;
				}
			}
		}
	}

	return fResult;
}

// The gradient and the desired color of the scalar field at the point {fX, fY, fZ}.
void CProteinSurfaceMQ::GradientAndColorIndexHeuristic(float r[3], float grad[3], int &colorIndex)
{
	int boxIndex = numBox[INDEX_X]*((int)((r[INDEX_Z] - molMin[INDEX_Z]) * invBoxSize[INDEX_Z])*numBox[INDEX_Y] + 
							  (int)((r[INDEX_Y] - molMin[INDEX_Y]) * invBoxSize[INDEX_Y]))
				   + (int)((r[INDEX_X] - molMin[INDEX_X]) * invBoxSize[INDEX_X]);

	int tmpIndex;
	float  coord[3];
	float r2, tmp, inv_radius;
	int index_x, index_y, index_z;
	float min_r2;
	int range = 1;
	const int maxRange = 5;

	// Zero the gradient
	grad[INDEX_X] = grad[INDEX_Y] = grad[INDEX_Z] = 0.0f;
	
	// Set colorIndex to -1 to initialize min_r2.
	colorIndex = -1;

	while(colorIndex == -1){
		// Check the current box and all neighbooring boxes too
		for(index_z = -range;index_z <= range;index_z ++){
			for(index_y = -range;index_y <= range;index_y ++){
				for(index_x = -range;index_x <= range;index_x ++){
					tmpIndex = boxIndex + index_z*xytotb + index_y*numBox[INDEX_X] + index_x;

					// Are we out of bounds?
					if((tmpIndex < 0) || (tmpIndex >= totb))
						continue;

					// Get the list of atoms in this box
					listRender<int>* currBox = atomBox[tmpIndex];
					
					// Are there any atms in this box?
					if(currBox == NULL)
						// No atoms in this box!
						continue;
					
					ListIterator<int> next((*currBox));
					int *ptr;

					while(ptr = next()){
						CAtom &currAtom = *(m_arrayAtom[*ptr]);
						
						coord[0] = currAtom.m_pos.x;
						coord[1] = currAtom.m_pos.y;
						coord[2] = currAtom.m_pos.z;

						inv_radius = 1.0f/(currAtom.m_fRadius + probeSphere);

						// Compute \Delta R
						coord[INDEX_X] = (r[INDEX_X] - coord[INDEX_X])*inv_radius;
						coord[INDEX_Y] = (r[INDEX_Y] - coord[INDEX_Y])*inv_radius;
						coord[INDEX_Z] = (r[INDEX_Z] - coord[INDEX_Z])*inv_radius;

						r2 = coord[INDEX_X]*coord[INDEX_X] + 
							 coord[INDEX_Y]*coord[INDEX_Y] + 
							 coord[INDEX_Z]*coord[INDEX_Z];
						
						// Track the index of the closest atom to assign
						// a color to this pactch of the surface
						if(colorIndex == -1){
							min_r2 = r2;
							colorIndex = *ptr;
						}
						else{
							if(min_r2 > r2){
								colorIndex = *ptr;
								min_r2 = r2;
							}
						}

						tmp = 1.0f/(r2*r2 + 1.0f/r2);
						tmp = tmp*tmp*inv_radius;

						grad[INDEX_X] += tmp*coord[INDEX_X];
						grad[INDEX_Y] += tmp*coord[INDEX_Y];
						grad[INDEX_Z] += tmp*coord[INDEX_Z];

					}
				}
			}
		}

		if(colorIndex != -1)
			return;

		// Increase the range until we find the atom
		range ++;

		if(range >= maxRange)
		{
			//	throw QmolError("Invalid color index in GradientAndColorIndex", __FILE__, __LINE__);
			TRACE("Invalid color index in GradientAndColorIndex");
		}
	}
}

// Build a 3D grid and collect the atom ids that fall into each grid cell.
void CProteinSurfaceMQ::BuildAtomBox()
{
	if( m_arrayAtom.size() == 0 )
	{
		//	throw QmolError("NULL ptr in BuildAtomBox", __FILE__, __LINE__);
		TRACE("#Atoms are 0 in BuildAtomBox");
	}

	float r[3];
  	int i;
  	int axb, ayb, azb, aindex;
	float tmp_xsize, tmp_ysize, tmp_zsize;
	int num_atom;

	num_atom = m_arrayAtom.size();

	if(num_atom == 0)
		return;

	// Find min/max bounds of molecule's coordinates.
	r[0] = m_arrayAtom[0]->m_pos.x;
	r[1] = m_arrayAtom[0]->m_pos.y;
	r[2] = m_arrayAtom[0]->m_pos.z;

	molMin[INDEX_X] = molMax[INDEX_X] = r[INDEX_X];
	molMin[INDEX_Y] = molMax[INDEX_Y] = r[INDEX_Y];
	molMin[INDEX_Z] = molMax[INDEX_Z] = r[INDEX_Z];

  	for(i = 1;i < num_atom; i++){
		r[0] = m_arrayAtom[i]->m_pos.x;
		r[1] = m_arrayAtom[i]->m_pos.y;
		r[2] = m_arrayAtom[i]->m_pos.z;
		
		if(r[INDEX_X] < molMin[INDEX_X])
			molMin[INDEX_X] = r[INDEX_X];
		else if(r[INDEX_X] > molMax[INDEX_X])
        	molMax[INDEX_X] = r[INDEX_X];

		if(r[INDEX_Y] < molMin[INDEX_Y])
        	molMin[INDEX_Y] = r[INDEX_Y];
		else if(r[INDEX_Y] > molMax[INDEX_Y])
        	molMax[INDEX_Y] = r[INDEX_Y];

		if(r[INDEX_Z] < molMin[INDEX_Z])
        	molMin[INDEX_Z] = r[INDEX_Z];
		else if(r[INDEX_Z] > molMax[INDEX_Z])
			molMax[INDEX_Z] = r[INDEX_Z];
	}

	molMin[INDEX_X] -= boxLength + 2.0f*probeSphere;
	molMin[INDEX_Y] -= boxLength + 2.0f*probeSphere;
	molMin[INDEX_Z] -= boxLength + 2.0f*probeSphere;

	molMax[INDEX_X] += boxLength + 2.0f*probeSphere;
	molMax[INDEX_Y] += boxLength + 2.0f*probeSphere;
	molMax[INDEX_Z] += boxLength + 2.0f*probeSphere;


	// From size of molecule, break up space into boxes of side length=BOX_LENGTH
  	// (or, if the molecule size is too large in any direction, the number of boxes is
  	// increased so that a maximum of MAX_NUM_BOX boxes are used in any direction).
	tmp_xsize = molMax[INDEX_X] - molMin[INDEX_X];
	tmp_ysize = molMax[INDEX_Y] - molMin[INDEX_Y];
	tmp_zsize = molMax[INDEX_Z] - molMin[INDEX_Z];

  	boxSize[INDEX_X] = tmp_xsize >= maxLength ? tmp_xsize/maxNumBox : boxLength;
  	boxSize[INDEX_Y] = tmp_ysize >= maxLength ? tmp_ysize/maxNumBox : boxLength;
  	boxSize[INDEX_Z] = tmp_zsize >= maxLength ? tmp_zsize/maxNumBox : boxLength;

	invBoxSize[INDEX_X] = 1.0f/boxSize[INDEX_X];
	invBoxSize[INDEX_Y] = 1.0f/boxSize[INDEX_Y];
	invBoxSize[INDEX_Z] = 1.0f/boxSize[INDEX_Z];

  	numBox[INDEX_X] = (int)(tmp_xsize * invBoxSize[INDEX_X]) + 1;
  	numBox[INDEX_Y] = (int)(tmp_ysize * invBoxSize[INDEX_Y]) + 1;
  	numBox[INDEX_Z] = (int)(tmp_zsize * invBoxSize[INDEX_Z]) + 1;

  	xytotb = numBox[INDEX_Y]*numBox[INDEX_X];
  	totb = xytotb*numBox[INDEX_Z];
	
	DeleteAtomBox();

	atomBox.Alloc(totb);

	for(i = 0; i < totb;i++)
		atomBox[i] = NULL;

  	// For all the atoms, put them in their particular box
  	for(i = 0; i < num_atom; i++) 
	{
		r[0] = m_arrayAtom[i]->m_pos.x;
		r[1] = m_arrayAtom[i]->m_pos.y;
		r[2] = m_arrayAtom[i]->m_pos.z;

    	axb = (int)((r[INDEX_X] - molMin[INDEX_X]) * invBoxSize[INDEX_X]);
    	ayb = (int)((r[INDEX_Y] - molMin[INDEX_Y]) * invBoxSize[INDEX_Y]);
    	azb = (int)((r[INDEX_Z] - molMin[INDEX_Z]) * invBoxSize[INDEX_Z]);
		
    	aindex = azb*xytotb + ayb*numBox[INDEX_X] + axb;

		if(atomBox[aindex] == NULL)
			// Only allocate memory for a list if there is at least one
			// atom in the box
			atomBox[aindex] = new listRender<int>;

		// Add the current record to box aindex.
		atomBox[aindex]->PushTop(i);
	}


}

void CProteinSurfaceMQ::DeleteAtomBox()
{
	// free up the storage space allocted for the grid search
	for(int i = 0;i < atomBox.Length(); i++)
    	if(atomBox[i])  
			delete atomBox[i];

	atomBox.Alloc(0);
}

void CProteinSurfaceMQ::BuildVertexArray()
{
	float triMax[3], triMin[3], triSize[3], invTriSize[3];
	int numTriBox[3];
  	int i, index_x, index_y, index_z, tmpIndex;
  	int axb, ayb, azb, aindex;
	float tmp_xsize, tmp_ysize, tmp_zsize;
	int tri_xytot, tri_tot;

	float vertex_cut_off = (meshSize*5.0e-1f)*(meshSize*5.0e-1f);

	int num_vertex = 0;

	if(triangleList.Length() == 0)
		return;

	ListIterator<Triangle> next(triangleList);
	Triangle *ptr;

	// Get the address of the first triangle
	ptr = next();

	// Find min/max bounds of all the triangle verticies
	triMin[INDEX_X] = triMax[INDEX_X] = ptr->vertexData[0][INDEX_X];
	triMin[INDEX_Y] = triMax[INDEX_Y] = ptr->vertexData[0][INDEX_Y];
	triMin[INDEX_Z] = triMax[INDEX_Z] = ptr->vertexData[0][INDEX_Z];

	do{
		for(i = 0;i < 3;i++){
			if(ptr->vertexData[i][INDEX_X] < triMin[INDEX_X])
				triMin[INDEX_X] = ptr->vertexData[i][INDEX_X];
			else if(ptr->vertexData[i][INDEX_X] > triMax[INDEX_X])
				triMax[INDEX_X] = ptr->vertexData[i][INDEX_X];
			
			if(ptr->vertexData[i][INDEX_Y] < triMin[INDEX_Y])
				triMin[INDEX_Y] = ptr->vertexData[i][INDEX_Y];
			else if(ptr->vertexData[i][INDEX_Y] > triMax[INDEX_Y])
				triMax[INDEX_Y] = ptr->vertexData[i][INDEX_Y];
			
			if(ptr->vertexData[i][INDEX_Z] < triMin[INDEX_Z])
				triMin[INDEX_Z] = ptr->vertexData[i][INDEX_Z];
			else if(ptr->vertexData[i][INDEX_Z] > triMax[INDEX_Z])
				triMax[INDEX_Z] = ptr->vertexData[i][INDEX_Z];
		}
	}
	while(ptr = next());


	// From size of molecule, break up space into boxes of side length=VERTEX_BOX_LENGTH
  	// (or, if the molecule size is too large in any direction, the number of boxes is
  	// increased so that a maximum of VERTEX_MAX_NUM_BOX boxes are used in any direction).
	tmp_xsize = triMax[INDEX_X] - triMin[INDEX_X];
	tmp_ysize = triMax[INDEX_Y] - triMin[INDEX_Y];
	tmp_zsize = triMax[INDEX_Z] - triMin[INDEX_Z];

  	triSize[INDEX_X] = tmp_xsize >= VERTEX_MAX_LENGTH ? tmp_xsize/VERTEX_MAX_NUM_BOX : VERTEX_BOX_LENGTH;
  	triSize[INDEX_Y] = tmp_ysize >= VERTEX_MAX_LENGTH ? tmp_ysize/VERTEX_MAX_NUM_BOX : VERTEX_BOX_LENGTH;
  	triSize[INDEX_Z] = tmp_zsize >= VERTEX_MAX_LENGTH ? tmp_zsize/VERTEX_MAX_NUM_BOX : VERTEX_BOX_LENGTH;

	invTriSize[INDEX_X] = 1.0f/triSize[INDEX_X];
	invTriSize[INDEX_Y] = 1.0f/triSize[INDEX_Y];
	invTriSize[INDEX_Z] = 1.0f/triSize[INDEX_Z];

  	numTriBox[INDEX_X] = (int)(tmp_xsize * invTriSize[INDEX_X]) + 1;
  	numTriBox[INDEX_Y] = (int)(tmp_ysize * invTriSize[INDEX_Y]) + 1;
  	numTriBox[INDEX_Z] = (int)(tmp_zsize * invTriSize[INDEX_Z]) + 1;

  	tri_xytot = numTriBox[INDEX_Y]*numTriBox[INDEX_X];
  	tri_tot = tri_xytot*numTriBox[INDEX_Z];

	vertexBox.Alloc(tri_tot);

	for(i = 0; i < tri_tot;i++)
		vertexBox[i] = NULL;

  	// For all the verticies, put them in their particular box
	next.Init(triangleList);

	while(ptr = next()){
		for(i = 0;i < 3;i++){
    		axb = (int)((ptr->vertexData[i][INDEX_X] - triMin[INDEX_X]) * invTriSize[INDEX_X]);
    		ayb = (int)((ptr->vertexData[i][INDEX_Y] - triMin[INDEX_Y]) * invTriSize[INDEX_Y]);
    		azb = (int)((ptr->vertexData[i][INDEX_Z] - triMin[INDEX_Z]) * invTriSize[INDEX_Z]);
				
    		aindex = azb*tri_xytot + ayb*numTriBox[INDEX_X] + axb;
			
#ifdef _DEBUG
			// Are we out of bounds?
			if((aindex < 0) || (aindex >= tri_tot))
			{
				//	throw QmolError("Vertex index out of bounds", __FILE__, __LINE__);
				TRACE("Vertex index out of bounds");
			}
#endif // _DEBUG

			if(vertexBox[aindex] == NULL)
				// Only allocate memory for a list if there is at least one
				// atom in the box
				vertexBox[aindex] = new listRender<VertexInfo>;
			
			// Vertex is distinct. Save the vertex
			VertexInfo tmpInfo;

			tmpInfo.index = i;
			tmpInfo.parent = ptr;
			vertexBox[aindex]->PushTop(tmpInfo);				
		}
	}

	// For all the verticies, locate the nearest neightboor vertex
	next.Init(triangleList);

	while(ptr = next()){
		for(i = 0;i < 3;i++){

			// Skip assigned verticies
			if(ptr->vertexIndex[i] != -1)
				continue;

    		axb = (int)((ptr->vertexData[i][INDEX_X] - triMin[INDEX_X]) * invTriSize[INDEX_X]);
    		ayb = (int)((ptr->vertexData[i][INDEX_Y] - triMin[INDEX_Y]) * invTriSize[INDEX_Y]);
    		azb = (int)((ptr->vertexData[i][INDEX_Z] - triMin[INDEX_Z]) * invTriSize[INDEX_Z]);
				
    		aindex = azb*tri_xytot + ayb*numTriBox[INDEX_X] + axb;
			
#ifdef _DEBUG
			// Are we out of bounds?
			if((aindex < 0) || (aindex >= tri_tot))
			{
				//	throw QmolError("Vertex index out of bounds", __FILE__, __LINE__);
				TRACE("Vertex index out of bounds");
			}

			if(vertexBox[aindex] == NULL)
			{
				// There must be at least one vertex in this box
				//	throw QmolError("Empty Vertex Box", __FILE__, __LINE__);
				TRACE("Empty Vertex Box");
			}
#endif // _DEBUG

			// Check the current box and all neighbooring boxes too
			for(index_z = -1;index_z <= 1;index_z ++){
				for(index_y = -1;index_y <= 1;index_y ++){
					for(index_x = -1;index_x <= 1;index_x ++){
						tmpIndex = aindex + index_z*tri_xytot + index_y*numTriBox[INDEX_X] + index_x;

						// Are we out of bounds?
						if((tmpIndex < 0) || (tmpIndex >= tri_tot))
							continue;

						// Get the list of verticies in this box
						listRender<VertexInfo>* currBox = vertexBox[tmpIndex];
							
						// Are there any verticies in this box?
						if(currBox == NULL)
							// No verticies in this box!
							continue;
							
						ListIterator<VertexInfo> nextVertex(*currBox);
						VertexInfo* tmpPtr;
						
						while(tmpPtr = nextVertex()){
							// Are the verticies in ptr distinct from the verticies
							// in tmpPtr?
							float dr2, tmp_dr2;

							dr2 = ptr->vertexPtr[i][INDEX_X] - 
								tmpPtr->parent->vertexPtr[tmpPtr->index][INDEX_X];

							dr2 *= dr2;

							if(dr2 > vertex_cut_off)
								continue;

							tmp_dr2 = ptr->vertexPtr[i][INDEX_Y] - 
								tmpPtr->parent->vertexPtr[tmpPtr->index][INDEX_Y];

							dr2 += tmp_dr2*tmp_dr2;

							if(dr2 > vertex_cut_off)
								continue;

							tmp_dr2 = ptr->vertexPtr[i][INDEX_Z] - 
								tmpPtr->parent->vertexPtr[tmpPtr->index][INDEX_Z];

							dr2 += tmp_dr2*tmp_dr2;

							if(dr2 > vertex_cut_off)
								continue;

							if(tmpPtr->parent->vertexIndex[tmpPtr->index] == -1){
								if(ptr->vertexIndex[i] == -1){
									ptr->vertexIndex[i] = num_vertex;
									num_vertex++;
								}
								
								tmpPtr->parent->vertexIndex[tmpPtr->index] = 
									ptr->vertexIndex[i];
								
								tmpPtr->parent->vertexPtr[tmpPtr->index] = 
									ptr->vertexPtr[i];
							}
							else{
								if(ptr->vertexIndex[i] == -1){
									ptr->vertexIndex[i] = 
										tmpPtr->parent->vertexIndex[tmpPtr->index];
									ptr->vertexPtr[i] = 
										tmpPtr->parent->vertexPtr[tmpPtr->index];
								}
							}
						}
					}
				}
			}
		}
	}

	// Free box memory
	for(i = 0; i < tri_tot;i++)
		if(vertexBox[i] != NULL)
			delete vertexBox[i];
	
	vertexBox.Alloc(0);

	// Whew! That was a lot of work just to determine which vertex goes where ...
	// Now build an array of verticies
	m_arrayVertexMQ.Alloc(3*num_vertex);
	m_arrayNormalMQ.Alloc(3*num_vertex);
	m_arrayIndexAtomMQ.Alloc(num_vertex);
	int triIndex[3];

	// Keep the user informed
	//CMainFrame *pFrame = (CMainFrame*)AfxGetApp()->m_pMainWnd;

	const int step_every = 10;
	int max_count = triangleList.Length() + num_vertex;
	int progress_counter = 0;

	next.Init(triangleList);

	int count = 0;

	long iProgress = GetMainActiveView()->InitProgress( 200);

	while(ptr = next()){

		// The indicies of each vertex in the triangle
		triIndex[0] = 3*ptr->vertexIndex[0];
		triIndex[1] = 3*ptr->vertexIndex[1];
		triIndex[2] = 3*ptr->vertexIndex[2];

		// Copy the triangle coordinates into the vertex 
		// array (this is the array that we will render from).
		m_arrayVertexMQ[triIndex[0]] = ptr->vertexPtr[0][INDEX_X];
		m_arrayVertexMQ[triIndex[0] + 1] = ptr->vertexPtr[0][INDEX_Y];
		m_arrayVertexMQ[triIndex[0] + 2] = ptr->vertexPtr[0][INDEX_Z];
		
		m_arrayVertexMQ[triIndex[1]] = ptr->vertexPtr[1][INDEX_X];
		m_arrayVertexMQ[triIndex[1] + 1] = ptr->vertexPtr[1][INDEX_Y];
		m_arrayVertexMQ[triIndex[1] + 2] = ptr->vertexPtr[1][INDEX_Z];
		
		m_arrayVertexMQ[triIndex[2]] = ptr->vertexPtr[2][INDEX_X];
		m_arrayVertexMQ[triIndex[2] + 1] = ptr->vertexPtr[2][INDEX_Y];
		m_arrayVertexMQ[triIndex[2] + 2] = ptr->vertexPtr[2][INDEX_Z];

		if((triIndex[0] == triIndex[1]) || (triIndex[0] == triIndex[2]) ||
			(triIndex[1] == triIndex[2])){

			// This triangle is NOT rendered
			ptr->vertexPtr[0] = NULL;
		}
		else{
			// Count the number of valid triangles
			count++;
		}

		progress_counter ++;

		if((progress_counter%step_every == 0)  )
		{
			// Advance the progress bar
			long count = (100*progress_counter)/max_count + 100;
			GetMainActiveView()->SetProgress(count, iProgress);

			PumpMessage();
		}
	}

	// Save the vertex indicies of triangles with non-zero area
	m_arrayIndexFaceMQ.Alloc(3*count);

	count = 0;
	next.Init(triangleList);

	while(ptr = next()){
		if(ptr->vertexPtr[0] != NULL){
			for(i = 0;i < 3;i++){	
				// Save the index
				m_arrayIndexFaceMQ[count] = ptr->vertexIndex[i];
				count++;
			}
		}
	}

	// Clean up the triangle list
	while(!triangleList.IsEmpty())
		triangleList.Pop();

	// Compute the normal and color
	for(i = 0;i < num_vertex;i++){
		GradientAndColorIndex ( m_arrayVertexMQ.Pointer() + i*3, m_arrayNormalMQ.Pointer() + i*3, m_arrayIndexAtomMQ[i] );

		progress_counter ++;
		if((progress_counter%step_every == 0) )
		{
			long count = (100*progress_counter)/max_count + 100;
			GetMainActiveView()->SetProgress(count, iProgress);

			PumpMessage();
		}
	}

	GetMainActiveView()->EndProgress(iProgress);

	// Make sure that all of the triangles have the correct winding order
	for(i = 0;i < m_arrayIndexFaceMQ.Length();i += 3)
	{
		int a, b, c;
		float AB[3], CB[3], N[3], tmpN[3];
		
		a = 3*m_arrayIndexFaceMQ[i];
		b = 3*m_arrayIndexFaceMQ[i + 1];
		c = 3*m_arrayIndexFaceMQ[i + 2];

		AB[INDEX_X] = m_arrayVertexMQ[a + INDEX_X] - m_arrayVertexMQ[b + INDEX_X];
		AB[INDEX_Y] = m_arrayVertexMQ[a + INDEX_Y] - m_arrayVertexMQ[b + INDEX_Y];
		AB[INDEX_Z] = m_arrayVertexMQ[a + INDEX_Z] - m_arrayVertexMQ[b + INDEX_Z];
		
		CB[INDEX_X] = m_arrayVertexMQ[c + INDEX_X] - m_arrayVertexMQ[b + INDEX_X];
		CB[INDEX_Y] = m_arrayVertexMQ[c + INDEX_Y] - m_arrayVertexMQ[b + INDEX_Y];
		CB[INDEX_Z] = m_arrayVertexMQ[c + INDEX_Z] - m_arrayVertexMQ[b + INDEX_Z];

		// Compute the cross product
		CROSS(N, AB, CB);

		const float eps = 1.0e-7f;
		//const float eps = 1.0e-2f;
		//	const float eps = 5.0e-1f;

		// Normalize N
		float mag = 1.0f/(float)sqrt(DOT(N, N));
		
		N[INDEX_X] *= mag;
		N[INDEX_Y] *= mag;
		N[INDEX_Z] *= mag;

		memcpy(tmpN, m_arrayNormalMQ.Pointer() + a, 3*sizeof(float));

		mag = (float)sqrt(DOT(tmpN, tmpN));

		if(DOT(N, tmpN)/mag > eps){			

			memcpy(tmpN, m_arrayNormalMQ.Pointer() + b, 3*sizeof(float));

			mag = (float)sqrt(DOT(tmpN, tmpN));
			
			if(DOT(N, tmpN)/mag > eps){

				memcpy(tmpN, m_arrayNormalMQ.Pointer() + c, 3*sizeof(float));

				mag = (float)sqrt(DOT(tmpN, tmpN));
			
				if(DOT(N, tmpN)/mag > eps){
					// Swap the a and c indicies to reverse the winding order
					m_arrayIndexFaceMQ[i] = c/3;
					m_arrayIndexFaceMQ[i + 2] = a/3;
				}
			}
		}
	}

}

int CProteinSurfaceMQ::GetSurfQuality()
{
	// "Quality" is inversely proportional to mesh size
	return (int)(100.0f*(1.0f - (meshSize - MIN_MESH_SIZE)/(MAX_MESH_SIZE - MIN_MESH_SIZE)));
}

void CProteinSurfaceMQ::SetSurfQuality(int m_quality)
{
	// "Quality" is inversely proportional to mesh size
	if((m_quality >= 0) && (m_quality <= 100))
	{
		meshSize = (100 - m_quality)*(MAX_MESH_SIZE - MIN_MESH_SIZE)/100.0f + MIN_MESH_SIZE;
	}
}

void CProteinSurfaceMQ::GetAtomSurfaceArea(arrayRender<float> &m_area)
{
	if(!validSurface)
	{
		//	throw QmolError("Can not compute surface area for invalid surface",__FILE__, __LINE__);
		TRACE("Can not compute surface area for invalid surface");
	}

	int i;

	// Zero the area arrat
	for(i = 0;i < m_area.Length();i++){
		m_area[i] = 0.0f;
	}

	int num_tri_vertex = m_arrayIndexFaceMQ.Length();

	for(i = 0;i < num_tri_vertex;i += 3){
		float triArea = TriangleArea(m_arrayIndexFaceMQ[i], 
									 m_arrayIndexFaceMQ[i+1], 
									 m_arrayIndexFaceMQ[i+2]);
		
		// Each vertex will be assigned 1/3 of the triangle area
		triArea /= 3.0f;

		if(m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i]] >= m_area.Length())
		{
			//	throw QmolError("Invalid atom index in GetAtomSurfaceArea", __FILE__, __LINE__);
			TRACE("Invalid atom index in GetAtomSurfaceArea");
		}
		else{
			m_area[m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i]]] += triArea;
		}

		if(m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i+1]] >= m_area.Length())
		{
			//	throw QmolError("Invalid atom index in GetAtomSurfaceArea", __FILE__, __LINE__);
			TRACE("Invalid atom index in GetAtomSurfaceArea");
		}
		else{
			m_area[m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i+1]]] += triArea;
		}

		if(m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i+2]] >= m_area.Length())
		{
			//	throw QmolError("Invalid atom index in GetAtomSurfaceArea", __FILE__, __LINE__);
			TRACE("Invalid atom index in GetAtomSurfaceArea");
		}
		else{
			m_area[m_arrayIndexAtomMQ[m_arrayIndexFaceMQ[i+2]]] += triArea;
		}
	}
}

// Traingle area is (1/2) base * hieght == 1/2 |A X B|
float CProteinSurfaceMQ::TriangleArea(int a, int b, int c)
{
	float A[3], B[3], C[3];

	A[INDEX_X] = m_arrayVertexMQ[3*a + INDEX_X] - m_arrayVertexMQ[3*b + INDEX_X];
	A[INDEX_Y] = m_arrayVertexMQ[3*a + INDEX_Y] - m_arrayVertexMQ[3*b + INDEX_Y];
	A[INDEX_Z] = m_arrayVertexMQ[3*a + INDEX_Z] - m_arrayVertexMQ[3*b + INDEX_Z];

	B[INDEX_X] = m_arrayVertexMQ[3*c + INDEX_X] - m_arrayVertexMQ[3*b + INDEX_X];
	B[INDEX_Y] = m_arrayVertexMQ[3*c + INDEX_Y] - m_arrayVertexMQ[3*b + INDEX_Y];
	B[INDEX_Z] = m_arrayVertexMQ[3*c + INDEX_Z] - m_arrayVertexMQ[3*b + INDEX_Z];

	CROSS(C, A, B);

	return 0.5f*(float)sqrt(DOT(C, C));
}

//==========================================================================================================
//==========================================================================================================
//==========================================================================================================

CProteinSurfaceMQ::CProteinSurfaceMQ()
{
	m_bUsed = FALSE;
	m_surfaceGenMethod = SURFACE_MQ;

	atomBox = NULL;
	validSurface = FALSE;

	// The raidus of the probe sphere is used in the heuristic 
	// solvent accessible surface calculation.
	probeSphere = 0.0f;

	// Try different iso-surface contour levels
	fTargetValue = 0.475f;

	surfaceType = HEURISTIC;

	targetValueCutOff = 2.0f*fTargetValue;

	// When a solvent probe sphere is used, 
	// the boxLength must be increased
	boxLength = 3.0f + probeSphere*probeSphere; 

	maxNumBox = 200;
	maxLength = boxLength*maxNumBox;

	SetSurfQuality(SURFACE_QUALITY);

	include_solvent_atoms = FALSE;

	color_by_atom = TRUE;

	// Make the color-by-atom surface opaque by default
	transparency = 255;

	// Make the usered defined surface color grey
	color[0] = color[1] = color[2] = 128;
	color[3] = 255;

	m_pChain = NULL;
	m_chainID = 0;
	m_modelID = 0;
	m_pPDB = NULL;

	m_probeSphere = 1.2;
	m_surfaceQuality = 3;
}

CProteinSurfaceMQ::~CProteinSurfaceMQ()
{
	DeleteAtomBox();
}

void CProteinSurfaceMQ::Init ( CPDB * pPDB, CChain * pChain, double probeSphere, int surfaceQuality, BOOL bAddHETATM )
{
	CProteinSurfaceBase::Init(pPDB, pChain, probeSphere, surfaceQuality, bAddHETATM );

	SetSurfQuality(m_surfaceQuality*10);
	SetProbeSphereRadius(m_probeSphere);
}

#define	SURFACE_HEADER	(_T("SURFACE_MQ_v05"))

HRESULT CProteinSurfaceMQ::CreateSurface()
{
	GetMainActiveView()->ResetProgress();

	m_arrayAtom.clear();
	m_arrayAtom.reserve(m_pChain->m_arrayAtom.size());

	for ( int i = 0 ; i < m_pChain->m_arrayAtom.size(); i++ )
	{
		if ( m_bAddHETATM == TRUE )
		{
			m_arrayAtom.push_back(m_pChain->m_arrayAtom[i]);
		}
		else
		{
			if ( m_pChain->m_arrayAtom[i]->m_bHETATM == FALSE )
				m_arrayAtom.push_back(m_pChain->m_arrayAtom[i]);
		}
	}

	if ( m_arrayAtom.size() == 0 )
		return E_FAIL;

	//
	//	    .
	//	vertexArray, indexArray, normalArray, colorArray
	//	
	HRESULT hr;

	char drive[_MAX_DRIVE];
	char dir[_MAX_DIR];
	char fname[_MAX_FNAME];
	char ext[_MAX_EXT];
	_splitpath(m_pPDB->m_strFilename, drive, dir, fname, ext );

	CString strSurfaceDir = GetMainApp()->m_strBaseSurfacePath;

	CString surfaceFilename;
	surfaceFilename.Format( _T("%s%s_%02d_%c_%03d_%.2f_%d_%d_%d.surface") , strSurfaceDir, fname, m_modelID, m_chainID, m_arrayAtom.size(), m_probeSphere, m_surfaceQuality , m_bAddHETATM , GetTypeGenSurface() );

	CFile file;
	file.Open(surfaceFilename, CFile::modeRead|CFile::typeBinary, NULL );
	if ( file.m_hFile != CFile::hFileNull )
	{
		TCHAR buffHeader[100]={0};
		file.Read(buffHeader, strlen(SURFACE_HEADER));
		if ( CString(buffHeader) == SURFACE_HEADER )
		{
			//	reading...
			LONG vertexLength = 0;
			LONG indexLength = 0;
			LONG normalLength = 0;
			LONG colorLength = 0;

			m_arrayVertex.clear();
			m_arrayIndexFace.clear();
			m_arrayNormal.clear();
			m_arrayIndexAtom.clear();

			//	.
			file.Read(&vertexLength, sizeof(LONG));
			m_arrayVertex.resize(vertexLength);
			file.Read(&m_arrayVertex[0], sizeof(D3DXVECTOR3)*vertexLength);

			file.Read(&indexLength, sizeof(LONG));
			m_arrayIndexFace.resize(indexLength);
			file.Read(&m_arrayIndexFace[0], sizeof(int)*indexLength);

			file.Read(&normalLength, sizeof(LONG));
			m_arrayNormal.resize(normalLength);
			file.Read(&m_arrayNormal[0], sizeof(D3DXVECTOR3)*normalLength);

			file.Read(&colorLength, sizeof(LONG));
			m_arrayIndexAtom.resize(colorLength);
			file.Read(&m_arrayIndexAtom[0], sizeof(int)*colorLength);

			validSurface = TRUE;
		}
		file.Close();
	}
	
	//
	if ( m_arrayVertex.size() == 0 )
	{
		//	Build Surface 
		BuildSurface(m_arrayAtom);

		//	CProteinSurfaceBase Copy
		//	D3DXVECTOR3
		m_arrayVertex.reserve(m_arrayVertexMQ.Length()/3);
		for ( int i = 0 ; i < m_arrayVertexMQ.Length(); i+=3 )
		{
			D3DXVECTOR3 vec(m_arrayVertexMQ[i], m_arrayVertexMQ[i+1], m_arrayVertexMQ[i+2] );
			m_arrayVertex.push_back(vec);
		}

		m_arrayNormal.reserve(m_arrayNormalMQ.Length()/3);
		for ( int i = 0 ; i < m_arrayNormalMQ.Length(); i+=3 )
		{
			D3DXVECTOR3 vec(m_arrayNormalMQ[i], m_arrayNormalMQ[i+1], m_arrayNormalMQ[i+2] );
			D3DXVec3Normalize(&vec, &vec);
			m_arrayNormal.push_back(vec);
		}

		m_arrayIndexFace.resize(m_arrayIndexFaceMQ.Length());
		CopyMemory(&m_arrayIndexFace[0], &m_arrayIndexFaceMQ[0], sizeof(INT)*m_arrayIndexFaceMQ.Length());

		m_arrayIndexAtom.resize(m_arrayIndexAtomMQ.Length());
		CopyMemory(&m_arrayIndexAtom[0], &m_arrayIndexAtomMQ[0], sizeof(INT)*m_arrayIndexAtomMQ.Length());

		//	
		validSurface = TRUE;

		//	 .
		CFile file(surfaceFilename, CFile::modeCreate|CFile::modeWrite|CFile::typeBinary );

		file.Write(SURFACE_HEADER, strlen(SURFACE_HEADER));

		LONG vertexLength = m_arrayVertex.size();
		LONG indexLength = m_arrayIndexFace.size();
		LONG normalLength = m_arrayNormal.size();
		LONG colorLength = m_arrayIndexAtom.size();

		file.Write(&vertexLength, sizeof(LONG));
		file.Write(&m_arrayVertex[0], sizeof(D3DXVECTOR3)*vertexLength);

		file.Write(&indexLength, sizeof(LONG));
		file.Write(&m_arrayIndexFace[0], sizeof(int)*indexLength);

		file.Write(&normalLength, sizeof(LONG));
		file.Write(&m_arrayNormal[0], sizeof(D3DXVECTOR3)*normalLength);

		file.Write(&colorLength, sizeof(LONG));
		file.Write(&m_arrayIndexAtom[0], sizeof(int)*colorLength);

		file.Close();
	}

	//	CProteinSurface VB, IB   .    ,
	//	Selection   VB, IB .

	//	 m_pChain->m_arrayAtom  index.
	//	 atom   vertex index.
	{
		m_ArrayArrayFaceIndex.clear();
		m_ArrayArrayFaceIndex.resize(m_arrayAtom.size());

		for ( long i = 0 ; i < m_arrayIndexFace.size() ; i++ )
		{
			long index = m_arrayIndexFace[i];
			long colorIndex = m_arrayIndexAtom[index];

			CSTLLONGArray & stlLongArray = m_ArrayArrayFaceIndex[colorIndex];

			//	vertexIndex  .
			//	
			//	CAtom  Surface vertex   vertex Index list .
			//	vertex Index list = 3* n
			//
			if ( i%3 == 0 )
			{
				stlLongArray.push_back(m_arrayIndexFace[i]);
				stlLongArray.push_back(m_arrayIndexFace[i+1]);
				stlLongArray.push_back(m_arrayIndexFace[i+2]);
			}
		}
	}

	//	Free orig buffer
	m_arrayVertexMQ.Alloc(0);
	m_arrayNormalMQ.Alloc(0);
	m_arrayIndexFaceMQ.Alloc(0);
	m_arrayIndexAtomMQ.Alloc(0);

	DeleteAtomBox();

	return S_OK;
}

float CProteinSurfaceMQ::GetSurfaceQuality(int quality)
{
	//	same operation as SetSurfQuality()
	float meshSize = MIN_MESH_SIZE;
	quality *= 10;
	if((quality >= 0) && (quality <= 100))
	{
		meshSize = (100 - quality)*(MAX_MESH_SIZE - MIN_MESH_SIZE)/100.0f + MIN_MESH_SIZE;
	}
	return meshSize;
}

long	CProteinSurfaceMQ::GetTypeGenSurface()
{
	return SURFACE_MQ;
}

