/* wsdlStub.h
   Generated by gSOAP 2.7.10 from wsdl.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef wsdlStub_H
#define wsdlStub_H
#include <vector>
#include "includes.h"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_xs__attribute_use
#define SOAP_TYPE_xs__attribute_use (57)
/* xs:attribute-use */
enum xs__attribute_use {optional = 0, prohibited = 1, required = 2, default_ = 3, fixed_ = 4};
#endif

#ifndef SOAP_TYPE_xs__processContents
#define SOAP_TYPE_xs__processContents (72)
/* xs:processContents */
enum xs__processContents {strict = 0, skip = 1, lax = 2};
#endif

#ifndef SOAP_TYPE_xs__formChoice
#define SOAP_TYPE_xs__formChoice (177)
/* xs:formChoice */
enum xs__formChoice {unqualified = 0, qualified = 1};
#endif

#ifndef SOAP_TYPE_soap__styleChoice
#define SOAP_TYPE_soap__styleChoice (217)
/* soap:styleChoice */
enum soap__styleChoice {rpc = 0, document = 1};
#endif

#ifndef SOAP_TYPE_soap__useChoice
#define SOAP_TYPE_soap__useChoice (221)
/* soap:useChoice */
enum soap__useChoice {literal = 0, encoded = 1};
#endif

#ifndef SOAP_TYPE_sd__mutability
#define SOAP_TYPE_sd__mutability (257)
/* sd:mutability */
enum sd__mutability {static_ = 0, constant = 1, extendable = 2, mutable_ = 3};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif







#ifndef SOAP_TYPE_xs__annotation
#define SOAP_TYPE_xs__annotation (30)
/* xs:annotation */
class SOAP_CMAC xs__annotation
{
public:
	char *documentation;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_xs__annotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__annotation() : documentation(NULL) { }
	virtual ~xs__annotation() { }
};
#endif

#ifndef SOAP_TYPE_xs__element
#define SOAP_TYPE_xs__element (31)
/* xs:element */
class SOAP_CMAC xs__element
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *type;	/* optional attribute */
	char *default_;	/* optional attribute */
	char *default__;	/* optional attribute */
	char *fixed;	/* optional attribute */
	bool nillable;	/* optional attribute */
	bool abstract;	/* optional attribute */
	char *substitutionGroup;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	class xs__simpleType *simpleType;	/* optional element of type xs:simpleType */
	class xs__complexType *complexType;	/* optional element of type xs:complexType */
private:
	class xs__schema *schemaRef;	/* not serialized */
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
	std::vector<xs__element * >substitutions;	/* not serialized */
public:
	xs__element();	/* transient */
	int traverse(xs__schema &_param_1);	/* transient */
	void schemaPtr(xs__schema *_param_2);	/* transient */
	void elementPtr(xs__element *_param_3);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_4);	/* transient */
	void complexTypePtr(xs__complexType *_param_5);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__element *elementPtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
	const std::vector<xs__element * >*substitutionsPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_xs__element */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__element() { }
};
#endif

#ifndef SOAP_TYPE_xs__attribute
#define SOAP_TYPE_xs__attribute (58)
/* xs:attribute */
class SOAP_CMAC xs__attribute
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	char *type;	/* optional attribute */
	enum xs__attribute_use use;	/* optional attribute */
	char *default_;	/* optional attribute */
	char *default__;	/* optional attribute */
	char *wsdl__arrayType;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__simpleType *simpleType;	/* optional element of type xs:simpleType */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attribute *attributeRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
public:
	xs__attribute();	/* transient */
	int traverse(xs__schema &_param_6);	/* transient */
	void schemaPtr(xs__schema *_param_7);	/* transient */
	void attributePtr(xs__attribute *_param_8);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_9);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__attribute *attributePtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_xs__attribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__attribute() { }
};
#endif

#ifndef SOAP_TYPE_xs__all
#define SOAP_TYPE_xs__all (69)
/* xs:all */
class SOAP_CMAC xs__all
{
public:
	std::vector<xs__element >element;	/* optional element of type xs:element */
	int traverse(xs__schema &_param_10);	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_xs__all */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__all()  { }
	virtual ~xs__all() { }
};
#endif

#ifndef SOAP_TYPE_xs__any
#define SOAP_TYPE_xs__any (74)
/* xs:any */
class SOAP_CMAC xs__any
{
public:
	char *namespace_;	/* optional attribute */
	enum xs__processContents processContents;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	int traverse(xs__schema &_param_11);	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_xs__any */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__any() : namespace_("##any"), processContents((enum xs__processContents)0), minOccurs(NULL), maxOccurs(NULL) { }
	virtual ~xs__any() { }
};
#endif

#ifndef SOAP_TYPE_xs__group
#define SOAP_TYPE_xs__group (76)
/* xs:group */
class SOAP_CMAC xs__group
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__all *all;	/* optional element of type xs:all */
	class xs__choice *choice;	/* optional element of type xs:choice */
	class xs__sequence *sequence;	/* optional element of type xs:sequence */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__group *groupRef;	/* not serialized */
public:
	xs__group();	/* transient */
	int traverse(xs__schema &_param_12);	/* transient */
	void schemaPtr(xs__schema *_param_13);	/* transient */
	void groupPtr(xs__group *_param_14);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__group *groupPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_xs__group */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__group() { }
};
#endif

#ifndef SOAP_TYPE_xs__choice
#define SOAP_TYPE_xs__choice (27)
/* xs:choice */
class SOAP_CMAC xs__choice
{
public:
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__choice >choice;	/* optional element of type xs:choice */
	std::vector<xs__sequence * >sequence;	/* optional element of type xs:sequence */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	std::vector<xs__any >any;	/* optional element of type xs:any */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__choice();	/* transient */
	int traverse(xs__schema &_param_15);	/* transient */
	void schemaPtr(xs__schema *_param_16);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_xs__choice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__choice() { }
};
#endif

#ifndef SOAP_TYPE_xs__sequence
#define SOAP_TYPE_xs__sequence (26)
/* xs:sequence */
class SOAP_CMAC xs__sequence
{
public:
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__choice >choice;	/* optional element of type xs:choice */
	std::vector<xs__sequence * >sequence;	/* optional element of type xs:sequence */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	std::vector<xs__any >any;	/* optional element of type xs:any */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	int traverse(xs__schema &_param_17);	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_xs__sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__sequence() : minOccurs(NULL), maxOccurs(NULL), annotation(NULL) { }
	virtual ~xs__sequence() { }
};
#endif

#ifndef SOAP_TYPE_xs__anyAttribute
#define SOAP_TYPE_xs__anyAttribute (97)
/* xs:anyAttribute */
class SOAP_CMAC xs__anyAttribute
{
public:
	char *namespace_;	/* optional attribute */
	enum xs__processContents processContents;	/* optional attribute */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_xs__anyAttribute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__anyAttribute() : namespace_("##any"), processContents((enum xs__processContents)0) { }
	virtual ~xs__anyAttribute() { }
};
#endif

#ifndef SOAP_TYPE_xs__attributeGroup
#define SOAP_TYPE_xs__attributeGroup (98)
/* xs:attributeGroup */
class SOAP_CMAC xs__attributeGroup
{
public:
	char *name;	/* optional attribute */
	char *ref;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__schema *schemaRef;	/* not serialized */
	xs__attributeGroup *attributeGroupRef;	/* not serialized */
public:
	xs__attributeGroup();	/* transient */
	int traverse(xs__schema &_param_18);	/* transient */
	void schemaPtr(xs__schema *_param_19);	/* transient */
	void attributeGroupPtr(xs__attributeGroup *_param_20);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	xs__attributeGroup *attributeGroupPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_xs__attributeGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__attributeGroup() { }
};
#endif

#ifndef SOAP_TYPE_xs__enumeration
#define SOAP_TYPE_xs__enumeration (110)
/* xs:enumeration */
class SOAP_CMAC xs__enumeration
{
public:
	char *value;	/* optional attribute */
	char *value_;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	int traverse(xs__schema &_param_21);	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_xs__enumeration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__enumeration() : value(NULL), value_(NULL), annotation(NULL) { }
	virtual ~xs__enumeration() { }
};
#endif

#ifndef SOAP_TYPE_xs__pattern
#define SOAP_TYPE_xs__pattern (112)
/* xs:pattern */
class SOAP_CMAC xs__pattern
{
public:
	char *value;	/* optional attribute */
	int traverse(xs__schema &_param_22);	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_xs__pattern */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__pattern() : value(NULL) { }
	virtual ~xs__pattern() { }
};
#endif

#ifndef SOAP_TYPE_xs__simpleContent
#define SOAP_TYPE_xs__simpleContent (114)
/* xs:simpleContent */
class SOAP_CMAC xs__simpleContent
{
public:
	class xs__extension *extension;	/* optional element of type xs:extension */
	class xs__restriction *restriction;	/* optional element of type xs:restriction */
	int traverse(xs__schema &_param_23);	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_xs__simpleContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__simpleContent() : extension(NULL), restriction(NULL) { }
	virtual ~xs__simpleContent() { }
};
#endif

#ifndef SOAP_TYPE_xs__simpleType
#define SOAP_TYPE_xs__simpleType (22)
/* xs:simpleType */
class SOAP_CMAC xs__simpleType
{
public:
	char *name;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	class xs__list *list;	/* optional element of type xs:list */
	class xs__union *union_;	/* optional element of type xs:union */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__simpleType();	/* transient */
	int traverse(xs__schema &_param_24);	/* transient */
	void schemaPtr(xs__schema *_param_25);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	int baseLevel();	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_xs__simpleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__simpleType() { }
};
#endif

#ifndef SOAP_TYPE_xs__extension
#define SOAP_TYPE_xs__extension (24)
/* xs:extension */
class SOAP_CMAC xs__extension
{
public:
	char *base;	/* optional attribute */
	xs__group *group;	/* optional element of type xs:group */
	xs__all *all;	/* optional element of type xs:all */
	xs__choice *choice;	/* optional element of type xs:choice */
	xs__sequence *sequence;	/* optional element of type xs:sequence */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__extension();	/* transient */
	int traverse(xs__schema &_param_26);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_27);	/* transient */
	void complexTypePtr(xs__complexType *_param_28);	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_xs__extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__extension() { }
};
#endif

#ifndef SOAP_TYPE_xs__length
#define SOAP_TYPE_xs__length (131)
/* xs:length */
class SOAP_CMAC xs__length
{
public:
	char *value;	/* optional attribute */
	bool fixed;	/* optional attribute */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE_xs__length */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__length() : value(NULL), fixed((bool)0) { }
	virtual ~xs__length() { }
};
#endif

#ifndef SOAP_TYPE_xs__whiteSpace
#define SOAP_TYPE_xs__whiteSpace (132)
/* xs:whiteSpace */
class SOAP_CMAC xs__whiteSpace
{
public:
	char *value;	/* optional attribute */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE_xs__whiteSpace */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__whiteSpace() : value(NULL) { }
	virtual ~xs__whiteSpace() { }
};
#endif

#ifndef SOAP_TYPE_xs__restriction
#define SOAP_TYPE_xs__restriction (25)
/* xs:restriction */
class SOAP_CMAC xs__restriction
{
public:
	char *base;	/* optional attribute */
	xs__group *group;	/* optional element of type xs:group */
	xs__all *all;	/* optional element of type xs:all */
	xs__choice *choice;	/* optional element of type xs:choice */
	xs__sequence *sequence;	/* optional element of type xs:sequence */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
	std::vector<xs__enumeration >enumeration;	/* optional element of type xs:enumeration */
	std::vector<xs__pattern >pattern;	/* optional element of type xs:pattern */
	xs__whiteSpace *whiteSpace;	/* optional element of type xs:whiteSpace */
	xs__length *length;	/* optional element of type xs:length */
	xs__length *minLength;	/* optional element of type xs:length */
	xs__length *maxLength;	/* optional element of type xs:length */
	xs__length *precision;	/* optional element of type xs:length */
	xs__length *scale;	/* optional element of type xs:length */
	xs__length *totalDigits;	/* optional element of type xs:length */
	xs__length *fractionDigits;	/* optional element of type xs:length */
	xs__length *minInclusive;	/* optional element of type xs:length */
	xs__length *maxInclusive;	/* optional element of type xs:length */
	xs__length *minExclusive;	/* optional element of type xs:length */
	xs__length *maxExclusive;	/* optional element of type xs:length */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
private:
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	xs__restriction();	/* transient */
	int traverse(xs__schema &_param_29);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_30);	/* transient */
	void complexTypePtr(xs__complexType *_param_31);	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_xs__restriction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__restriction() { }
};
#endif

#ifndef SOAP_TYPE_xs__list
#define SOAP_TYPE_xs__list (28)
/* xs:list */
class SOAP_CMAC xs__list
{
public:
	char *itemType;	/* optional attribute */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
private:
	xs__simpleType *itemTypeRef;	/* not serialized */
public:
	xs__list();	/* transient */
	int traverse(xs__schema &_param_32);	/* transient */
	void itemTypePtr(xs__simpleType *_param_33);	/* transient */
	xs__simpleType *itemTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_xs__list */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__list() { }
};
#endif

#ifndef SOAP_TYPE_xs__union
#define SOAP_TYPE_xs__union (29)
/* xs:union */
class SOAP_CMAC xs__union
{
public:
	char *memberTypes;	/* optional attribute */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	int traverse(xs__schema &_param_34);	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_xs__union */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__union() : memberTypes(NULL) { }
	virtual ~xs__union() { }
};
#endif

#ifndef SOAP_TYPE_xs__complexContent
#define SOAP_TYPE_xs__complexContent (149)
/* xs:complexContent */
class SOAP_CMAC xs__complexContent
{
public:
	bool mixed;	/* optional attribute */
	xs__extension *extension;	/* optional element of type xs:extension */
	xs__restriction *restriction;	/* optional element of type xs:restriction */
	int traverse(xs__schema &_param_35);	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE_xs__complexContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xs__complexContent() : mixed((bool)0), extension(NULL), restriction(NULL) { }
	virtual ~xs__complexContent() { }
};
#endif

#ifndef SOAP_TYPE_xs__complexType
#define SOAP_TYPE_xs__complexType (23)
/* xs:complexType */
class SOAP_CMAC xs__complexType
{
public:
	char *name;	/* optional attribute */
	bool abstract;	/* optional attribute */
	bool mixed;	/* optional attribute */
	xs__annotation *annotation;	/* optional element of type xs:annotation */
	xs__simpleContent *simpleContent;	/* optional element of type xs:simpleContent */
	xs__complexContent *complexContent;	/* optional element of type xs:complexContent */
	xs__all *all;	/* optional element of type xs:all */
	xs__choice *choice;	/* optional element of type xs:choice */
	xs__sequence *sequence;	/* optional element of type xs:sequence */
	xs__any *any;	/* optional element of type xs:any */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	xs__anyAttribute *anyAttribute;	/* optional element of type xs:anyAttribute */
private:
	xs__schema *schemaRef;	/* not serialized */
	int level;	/* not serialized */
public:
	xs__complexType();	/* transient */
	int traverse(xs__schema &_param_36);	/* transient */
	void schemaPtr(xs__schema *_param_37);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
	int baseLevel();	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_xs__complexType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__complexType() { }
};
#endif

#ifndef SOAP_TYPE_xs__import
#define SOAP_TYPE_xs__import (159)
/* xs:import */
class SOAP_CMAC xs__import
{
public:
	char *namespace_;	/* optional attribute */
	char *schemaLocation;	/* optional attribute */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__import();	/* transient */
	int traverse(xs__schema &_param_38);	/* transient */
	void schemaPtr(xs__schema *_param_39);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_xs__import */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__import() { }
};
#endif

#ifndef SOAP_TYPE_xs__include
#define SOAP_TYPE_xs__include (164)
/* xs:include */
class SOAP_CMAC xs__include
{
public:
	char *schemaLocation;	/* optional attribute */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__include();	/* transient */
	int preprocess(xs__schema &_param_40);	/* transient */
	int traverse(xs__schema &_param_41);	/* transient */
	void schemaPtr(xs__schema *_param_42);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE_xs__include */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__include() { }
};
#endif

#ifndef SOAP_TYPE_xs__redefine
#define SOAP_TYPE_xs__redefine (170)
/* xs:redefine */
class SOAP_CMAC xs__redefine
{
public:
	char *schemaLocation;	/* optional attribute */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	std::vector<xs__complexType >complexType;	/* optional element of type xs:complexType */
private:
	xs__schema *schemaRef;	/* not serialized */
public:
	xs__redefine();	/* transient */
	int preprocess(xs__schema &_param_43);	/* transient */
	int traverse(xs__schema &_param_44);	/* transient */
	void schemaPtr(xs__schema *_param_45);	/* transient */
	xs__schema *schemaPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_xs__redefine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~xs__redefine() { }
};
#endif

#ifndef SOAP_TYPE_xs__schema
#define SOAP_TYPE_xs__schema (21)
/* xs:schema */
class SOAP_CMAC xs__schema
{
public:
	char *targetNamespace;	/* optional attribute */
	char *version;	/* optional attribute */
	enum xs__formChoice attributeFormDefault;	/* optional attribute */
	enum xs__formChoice elementFormDefault;	/* optional attribute */
	std::vector<xs__include >include;	/* optional element of type xs:include */
	std::vector<xs__redefine >redefine;	/* optional element of type xs:redefine */
	std::vector<xs__import >import;	/* optional element of type xs:import */
	std::vector<xs__attribute >attribute;	/* optional element of type xs:attribute */
	std::vector<xs__element >element;	/* optional element of type xs:element */
	std::vector<xs__group >group;	/* optional element of type xs:group */
	std::vector<xs__attributeGroup >attributeGroup;	/* optional element of type xs:attributeGroup */
	std::vector<xs__simpleType >simpleType;	/* optional element of type xs:simpleType */
	std::vector<xs__complexType >complexType;	/* optional element of type xs:complexType */
	struct soap *soap;	/* transient */
private:
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient */	/* not serialized */
	SetOfString builtinElementSet;	/* transient */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient */	/* not serialized */
public:
	xs__schema();	/* transient */
	xs__schema(struct soap *_param_46);	/* transient */
	xs__schema(struct soap *_param_47, const char *_param_48, const char *_param_49);	/* transient */
	virtual ~xs__schema();	/* transient */
	int get(struct soap *_param_50);	/* transient */
	int preprocess();	/* transient */
	int insert(xs__schema &_param_51);	/* transient */
	int traverse();	/* transient */
	int read(const char *_param_52, const char *_param_53);	/* transient */
	void sourceLocation(const char *_param_54);	/* transient */
	const char *sourceLocation();	/* transient */
	int error();	/* transient */
	void print_fault();	/* transient */
	void builtinType(const char *_param_55);	/* transient */
	void builtinElement(const char *_param_56);	/* transient */
	void builtinAttribute(const char *_param_57);	/* transient */
	const SetOfString &builtinTypes() const;	/* transient */	/* not serialized */
	const SetOfString &builtinElements() const;	/* transient */	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* transient */	/* not serialized */
	friend ostream &operator<<(ostream &_param_58, const xs__schema &_param_59);	/* transient */
	friend istream &operator>>(istream &_param_60, xs__schema &_param_61);	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_xs__schema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#ifndef SOAP_TYPE_soap__binding
#define SOAP_TYPE_soap__binding (218)
/* soap:binding */
class SOAP_CMAC soap__binding
{
public:
	char *transport;	/* optional attribute */
	enum soap__styleChoice *style;	/* optional attribute */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_soap__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__binding() : transport(NULL), style(NULL) { }
	virtual ~soap__binding() { }
};
#endif

#ifndef SOAP_TYPE_soap__operation
#define SOAP_TYPE_soap__operation (220)
/* soap:operation */
class SOAP_CMAC soap__operation
{
public:
	char *soapAction;	/* optional attribute */
	enum soap__styleChoice *style;	/* optional attribute */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_soap__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__operation() : soapAction(NULL), style(NULL) { }
	virtual ~soap__operation() { }
};
#endif

#ifndef SOAP_TYPE_soap__body
#define SOAP_TYPE_soap__body (222)
/* soap:body */
class SOAP_CMAC soap__body
{
public:
	char *encodingStyle;	/* optional attribute */
	char *parts;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *namespace_;	/* optional attribute */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_soap__body */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__body() : encodingStyle(NULL), parts(NULL), use((enum soap__useChoice)0), namespace_(NULL) { }
	virtual ~soap__body() { }
};
#endif

#ifndef SOAP_TYPE_soap__fault
#define SOAP_TYPE_soap__fault (223)
/* soap:fault */
class SOAP_CMAC soap__fault
{
public:
	char *name;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *namespace_;	/* optional attribute */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_soap__fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__fault() : name(NULL), encodingStyle(NULL), use((enum soap__useChoice)0), namespace_(NULL) { }
	virtual ~soap__fault() { }
};
#endif

#ifndef SOAP_TYPE_soap__headerfault
#define SOAP_TYPE_soap__headerfault (224)
/* soap:headerfault */
class SOAP_CMAC soap__headerfault
{
public:
	char *message;	/* optional attribute */
	char *part;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	char *namespace_;	/* optional attribute */
private:
	class wsdl__message *messageRef;	/* not serialized */
	class wsdl__part *partRef;	/* not serialized */
public:
	int traverse(class wsdl__definitions &_param_62);	/* transient */
	void messagePtr(wsdl__message *_param_63);	/* transient */
	void partPtr(wsdl__part *_param_64);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	wsdl__part *partPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_soap__headerfault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__headerfault() : message(NULL), part(NULL), use((enum soap__useChoice)0), encodingStyle(NULL), namespace_(NULL), messageRef(NULL), partRef(NULL) { }
	virtual ~soap__headerfault() { }
};
#endif

#ifndef SOAP_TYPE_soap__header
#define SOAP_TYPE_soap__header (235)
/* soap:header */
class SOAP_CMAC soap__header
{
public:
	char *message;	/* optional attribute */
	char *part;	/* optional attribute */
	enum soap__useChoice use;	/* optional attribute */
	char *encodingStyle;	/* optional attribute */
	char *namespace_;	/* optional attribute */
	std::vector<soap__headerfault >headerfault;	/* optional element of type soap:headerfault */
private:
	wsdl__message *messageRef;	/* not serialized */
	wsdl__part *partRef;	/* not serialized */
public:
	int traverse(wsdl__definitions &_param_65);	/* transient */
	void messagePtr(wsdl__message *_param_66);	/* transient */
	void partPtr(wsdl__part *_param_67);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
	wsdl__part *partPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_soap__header */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__header() : message(NULL), part(NULL), use((enum soap__useChoice)0), encodingStyle(NULL), namespace_(NULL), messageRef(NULL), partRef(NULL) { }
	virtual ~soap__header() { }
};
#endif

#ifndef SOAP_TYPE_soap__address
#define SOAP_TYPE_soap__address (242)
/* soap:address */
class SOAP_CMAC soap__address
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_soap__address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         soap__address() : location(NULL) { }
	virtual ~soap__address() { }
};
#endif

#ifndef SOAP_TYPE_mime__content
#define SOAP_TYPE_mime__content (243)
/* mime:content */
class SOAP_CMAC mime__content
{
public:
	char *part;	/* optional attribute */
	char *type;	/* optional attribute */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_mime__content */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__content() : part(NULL), type(NULL) { }
	virtual ~mime__content() { }
};
#endif

#ifndef SOAP_TYPE_mime__part
#define SOAP_TYPE_mime__part (244)
/* mime:part */
class SOAP_CMAC mime__part
{
public:
	soap__body *soap__body_;	/* optional element of type soap:body */
	std::vector<soap__header >soap__header_;	/* optional element of type soap:header */
	std::vector<mime__content >content;	/* optional element of type mime:content */
	int traverse(wsdl__definitions &_param_68);	/* transient */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_mime__part */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__part() : soap__body_(NULL) { }
	virtual ~mime__part() { }
};
#endif

#ifndef SOAP_TYPE_mime__multipartRelated
#define SOAP_TYPE_mime__multipartRelated (249)
/* mime:multipartRelated */
class SOAP_CMAC mime__multipartRelated
{
public:
	std::vector<mime__part >part;	/* optional element of type mime:part */
	int traverse(wsdl__definitions &_param_69);	/* transient */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_mime__multipartRelated */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mime__multipartRelated()  { }
	virtual ~mime__multipartRelated() { }
};
#endif

#ifndef SOAP_TYPE_dime__message
#define SOAP_TYPE_dime__message (252)
/* dime:message */
class SOAP_CMAC dime__message
{
public:
	char *layout;	/* optional attribute */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE_dime__message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         dime__message() : layout(NULL) { }
	virtual ~dime__message() { }
};
#endif

#ifndef SOAP_TYPE_http__address
#define SOAP_TYPE_http__address (253)
/* http:address */
class SOAP_CMAC http__address
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE_http__address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__address() : location(NULL) { }
	virtual ~http__address() { }
};
#endif

#ifndef SOAP_TYPE_http__binding
#define SOAP_TYPE_http__binding (254)
/* http:binding */
class SOAP_CMAC http__binding
{
public:
	char *verb;	/* optional attribute */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE_http__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__binding() : verb(NULL) { }
	virtual ~http__binding() { }
};
#endif

#ifndef SOAP_TYPE_http__operation
#define SOAP_TYPE_http__operation (255)
/* http:operation */
class SOAP_CMAC http__operation
{
public:
	char *location;	/* optional attribute */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE_http__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         http__operation() : location(NULL) { }
	virtual ~http__operation() { }
};
#endif

#ifndef SOAP_TYPE_sd__serviceData
#define SOAP_TYPE_sd__serviceData (258)
/* sd:serviceData */
class SOAP_CMAC sd__serviceData
{
public:
	char *name;	/* optional attribute */
	char *type;	/* optional attribute */
	bool nillable;	/* optional attribute */
	char *minOccurs;	/* optional attribute */
	char *maxOccurs;	/* optional attribute */
	enum sd__mutability mutability;	/* optional attribute */
	bool modifiable;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE_sd__serviceData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sd__serviceData() : name(NULL), type(NULL), nillable((bool)0), minOccurs(NULL), maxOccurs(NULL), mutability((enum sd__mutability)2), modifiable((bool)0) { }
	virtual ~sd__serviceData() { }
};
#endif

#ifndef SOAP_TYPE_sd__staticServiceDataValues
#define SOAP_TYPE_sd__staticServiceDataValues (259)
/* sd:staticServiceDataValues */
class SOAP_CMAC sd__staticServiceDataValues
{
public:
	int __type;	/* any type of element <any> (defined below) */
	void *_any;	/* transient */
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_sd__staticServiceDataValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         sd__staticServiceDataValues() : __type(0), _any(NULL) { }
	virtual ~sd__staticServiceDataValues() { }
};
#endif

#ifndef SOAP_TYPE_gwsdl__portType
#define SOAP_TYPE_gwsdl__portType (261)
/* gwsdl:portType */
class SOAP_CMAC gwsdl__portType
{
public:
	char *name;	/* optional attribute */
	char *extends;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<class wsdl__operation * >operation;	/* optional element of type wsdl:operation */
	std::vector<sd__serviceData >sd__serviceData_;	/* optional element of type sd:serviceData */
	sd__staticServiceDataValues *sd__staticServiceDataValues_;	/* optional element of type sd:staticServiceDataValues */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_gwsdl__portType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gwsdl__portType() : name(NULL), extends(NULL), documentation(NULL), sd__staticServiceDataValues_(NULL) { }
	virtual ~gwsdl__portType() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__import
#define SOAP_TYPE_wsdl__import (266)
/* wsdl:import */
class SOAP_CMAC wsdl__import
{
public:
	char *namespace_;	/* optional attribute */
	char *location;	/* optional attribute */
private:
	wsdl__definitions *definitionsRef;	/* not serialized */
public:
	wsdl__import();	/* transient */
	int preprocess(wsdl__definitions &_param_70);	/* transient */
	int traverse(wsdl__definitions &_param_71);	/* transient */
	void definitionsPtr(wsdl__definitions *_param_72);	/* transient */
	wsdl__definitions *definitionsPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE_wsdl__import */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__import() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__types
#define SOAP_TYPE_wsdl__types (274)
/* wsdl:types */
class SOAP_CMAC wsdl__types
{
public:
	char *documentation;	/* optional element of type xsd:string */
	std::vector<xs__schema * >xs__schema_;	/* optional element of type xs:schema */
	int preprocess(wsdl__definitions &_param_73);	/* transient */
	int traverse(wsdl__definitions &_param_74);	/* transient */
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE_wsdl__types */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__types() : documentation(NULL) { }
	virtual ~wsdl__types() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__part
#define SOAP_TYPE_wsdl__part (216)
/* wsdl:part */
class SOAP_CMAC wsdl__part
{
public:
	char *name;	/* optional attribute */
	char *element;	/* optional attribute */
	char *type;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
private:
	xs__element *elementRef;	/* not serialized */
	xs__simpleType *simpleTypeRef;	/* not serialized */
	xs__complexType *complexTypeRef;	/* not serialized */
public:
	wsdl__part();	/* transient */
	int traverse(wsdl__definitions &_param_75);	/* transient */
	void elementPtr(xs__element *_param_76);	/* transient */
	void simpleTypePtr(xs__simpleType *_param_77);	/* transient */
	void complexTypePtr(xs__complexType *_param_78);	/* transient */
	xs__element *elementPtr() const;	/* transient */
	xs__simpleType *simpleTypePtr() const;	/* transient */
	xs__complexType *complexTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_wsdl__part */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__part() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__message
#define SOAP_TYPE_wsdl__message (215)
/* wsdl:message */
class SOAP_CMAC wsdl__message
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsdl__part >part;	/* optional element of type wsdl:part */
	int traverse(wsdl__definitions &_param_79);	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_wsdl__message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__message() : name(NULL), documentation(NULL) { }
	virtual ~wsdl__message() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__input
#define SOAP_TYPE_wsdl__input (288)
/* wsdl:input */
class SOAP_CMAC wsdl__input
{
public:
	char *name;	/* optional attribute */
	char *message;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
private:
	wsdl__message *messageRef;	/* not serialized */
public:
	wsdl__input();	/* transient */
	int traverse(wsdl__definitions &_param_80);	/* transient */
	void messagePtr(wsdl__message *_param_81);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_wsdl__input */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__input() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__output
#define SOAP_TYPE_wsdl__output (293)
/* wsdl:output */
class SOAP_CMAC wsdl__output
{
public:
	char *name;	/* optional attribute */
	char *message;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
private:
	wsdl__message *messageRef;	/* not serialized */
public:
	wsdl__output();	/* transient */
	int traverse(wsdl__definitions &_param_82);	/* transient */
	void messagePtr(wsdl__message *_param_83);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_wsdl__output */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__output() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__fault
#define SOAP_TYPE_wsdl__fault (298)
/* wsdl:fault */
class SOAP_CMAC wsdl__fault
{
public:
	char *name;	/* optional attribute */
	char *message;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
private:
	wsdl__message *messageRef;	/* not serialized */
public:
	wsdl__fault();	/* transient */
	int traverse(wsdl__definitions &_param_84);	/* transient */
	void messagePtr(wsdl__message *_param_85);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_wsdl__fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__fault() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__operation
#define SOAP_TYPE_wsdl__operation (256)
/* wsdl:operation */
class SOAP_CMAC wsdl__operation
{
public:
	char *name;	/* optional attribute */
	char *parameterOrder;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	wsdl__input *input;	/* optional element of type wsdl:input */
	wsdl__output *output;	/* optional element of type wsdl:output */
	std::vector<wsdl__fault >fault;	/* optional element of type wsdl:fault */
	int traverse(wsdl__definitions &_param_86);	/* transient */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_wsdl__operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__operation() : name(NULL), parameterOrder(NULL), documentation(NULL), input(NULL), output(NULL) { }
	virtual ~wsdl__operation() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__portType
#define SOAP_TYPE_wsdl__portType (307)
/* wsdl:portType */
class SOAP_CMAC wsdl__portType
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsdl__operation >operation;	/* optional element of type wsdl:operation */
	int traverse(wsdl__definitions &_param_87);	/* transient */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE_wsdl__portType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__portType() : name(NULL), documentation(NULL) { }
	virtual ~wsdl__portType() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_input
#define SOAP_TYPE_wsdl__ext_input (310)
/* wsdl:ext-input */
class SOAP_CMAC wsdl__ext_input
{
public:
	char *documentation;	/* optional element of type xsd:string */
	dime__message *dime__message_;	/* optional element of type dime:message */
	soap__body *soap__body_;	/* optional element of type soap:body */
	mime__multipartRelated *mime__multipartRelated_;	/* optional element of type mime:multipartRelated */
	mime__content *mime__content_;	/* optional element of type mime:content */
	std::vector<soap__header >soap__header_;	/* optional element of type soap:header */
	int traverse(wsdl__definitions &_param_88);	/* transient */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE_wsdl__ext_input */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__ext_input() : documentation(NULL), dime__message_(NULL), soap__body_(NULL), mime__multipartRelated_(NULL), mime__content_(NULL) { }
	virtual ~wsdl__ext_input() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_output
#define SOAP_TYPE_wsdl__ext_output (315)
/* wsdl:ext-output */
class SOAP_CMAC wsdl__ext_output
{
public:
	char *documentation;	/* optional element of type xsd:string */
	dime__message *dime__message_;	/* optional element of type dime:message */
	soap__body *soap__body_;	/* optional element of type soap:body */
	mime__multipartRelated *mime__multipartRelated_;	/* optional element of type mime:multipartRelated */
	mime__content *mime__content_;	/* optional element of type mime:content */
	std::vector<soap__header >soap__header_;	/* optional element of type soap:header */
	int traverse(wsdl__definitions &_param_89);	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE_wsdl__ext_output */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__ext_output() : documentation(NULL), dime__message_(NULL), soap__body_(NULL), mime__multipartRelated_(NULL), mime__content_(NULL) { }
	virtual ~wsdl__ext_output() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__ext_fault
#define SOAP_TYPE_wsdl__ext_fault (317)
/* wsdl:ext-fault */
class SOAP_CMAC wsdl__ext_fault
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	soap__fault *soap__fault_;	/* optional element of type soap:fault */
private:
	wsdl__message *messageRef;	/* not serialized */
public:
	wsdl__ext_fault();	/* transient */
	int traverse(wsdl__definitions &_param_90);	/* transient */
	void messagePtr(wsdl__message *_param_91);	/* transient */
	wsdl__message *messagePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE_wsdl__ext_fault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__ext_fault() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__binding_operation
#define SOAP_TYPE_wsdl__binding_operation (323)
/* wsdl:binding-operation */
class SOAP_CMAC wsdl__binding_operation
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	soap__operation *soap__operation_;	/* optional element of type soap:operation */
	http__operation *http__operation_;	/* optional element of type http:operation */
	wsdl__ext_input *input;	/* optional element of type wsdl:ext-input */
	wsdl__ext_output *output;	/* optional element of type wsdl:ext-output */
	std::vector<wsdl__ext_fault >fault;	/* optional element of type wsdl:ext-fault */
private:
	wsdl__operation *operationRef;	/* not serialized */
public:
	wsdl__binding_operation();	/* transient */
	int traverse(wsdl__definitions &_param_92, wsdl__portType *_param_93);	/* transient */
	void operationPtr(wsdl__operation *_param_94);	/* transient */
	wsdl__operation *operationPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE_wsdl__binding_operation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__binding_operation() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__binding
#define SOAP_TYPE_wsdl__binding (335)
/* wsdl:binding */
class SOAP_CMAC wsdl__binding
{
public:
	char *name;	/* optional attribute */
	char *type;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	soap__binding *soap__binding_;	/* optional element of type soap:binding */
	http__binding *http__binding_;	/* optional element of type http:binding */
	std::vector<wsdl__binding_operation >operation;	/* optional element of type wsdl:binding-operation */
private:
	wsdl__portType *portTypeRef;	/* not serialized */
public:
	wsdl__binding();	/* transient */
	int traverse(wsdl__definitions &_param_95);	/* transient */
	void portTypePtr(wsdl__portType *_param_96);	/* transient */
	wsdl__portType *portTypePtr() const;	/* transient */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE_wsdl__binding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__binding() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__port
#define SOAP_TYPE_wsdl__port (344)
/* wsdl:port */
class SOAP_CMAC wsdl__port
{
public:
	char *name;	/* optional attribute */
	char *binding;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	soap__address *soap__address_;	/* optional element of type soap:address */
	http__address *http__address_;	/* optional element of type http:address */
private:
	wsdl__binding *bindingRef;	/* not serialized */
public:
	wsdl__port();	/* transient */
	int traverse(wsdl__definitions &_param_97);	/* transient */
	void bindingPtr(wsdl__binding *_param_98);	/* transient */
	wsdl__binding *bindingPtr() const;	/* transient */
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE_wsdl__port */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~wsdl__port() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__service
#define SOAP_TYPE_wsdl__service (353)
/* wsdl:service */
class SOAP_CMAC wsdl__service
{
public:
	char *name;	/* optional attribute */
	char *documentation;	/* optional element of type xsd:string */
	std::vector<wsdl__port >port;	/* optional element of type wsdl:port */
	int traverse(wsdl__definitions &_param_99);	/* transient */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE_wsdl__service */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         wsdl__service() : name(NULL), documentation(NULL) { }
	virtual ~wsdl__service() { }
};
#endif

#ifndef SOAP_TYPE_wsdl__definitions
#define SOAP_TYPE_wsdl__definitions (214)
/* wsdl:definitions */
class SOAP_CMAC wsdl__definitions
{
public:
	char *name;	/* optional attribute */
	char *targetNamespace;	/* optional attribute */
	char *version;	/* optional attribute */
	std::vector<wsdl__import >import;	/* optional element of type wsdl:import */
	char *documentation;	/* optional element of type xsd:string */
	wsdl__types *types;	/* optional element of type wsdl:types */
	std::vector<wsdl__message >message;	/* optional element of type wsdl:message */
	std::vector<wsdl__portType >portType;	/* optional element of type wsdl:portType */
	std::vector<wsdl__binding >binding;	/* optional element of type wsdl:binding */
	std::vector<wsdl__service >service;	/* optional element of type wsdl:service */
	std::vector<gwsdl__portType >gwsdl__portType_;	/* optional element of type gwsdl:portType */
	struct soap *soap;	/* transient */
private:
	bool updated;	/* not serialized */
	char *location;	/* not serialized */
	int redirs;	/* not serialized */
	SetOfString builtinTypeSet;	/* transient */	/* not serialized */
	SetOfString builtinElementSet;	/* transient */	/* not serialized */
	SetOfString builtinAttributeSet;	/* transient */	/* not serialized */
public:
	wsdl__definitions();	/* transient */
	wsdl__definitions(struct soap *_param_100, const char *_param_101, const char *_param_102);	/* transient */
	virtual ~wsdl__definitions();	/* transient */
	int get(struct soap *_param_103);	/* transient */
	int preprocess();	/* transient */
	int traverse();	/* transient */
	int read(int _param_104, char **_param_105);	/* transient */
	int read(const char *cwd, const char *_param_106);	/* transient */
	const char *sourceLocation();	/* transient */
	int error();	/* transient */
	void print_fault();	/* transient */
	void builtinType(const char *_param_107);	/* transient */
	void builtinTypes(const SetOfString &_param_108);	/* transient */
	void builtinElement(const char *_param_109);	/* transient */
	void builtinElements(const SetOfString &_param_110);	/* transient */
	void builtinAttribute(const char *_param_111);	/* transient */
	void builtinAttributes(const SetOfString &_param_112);	/* transient */
	const SetOfString &builtinTypes() const;	/* transient */	/* not serialized */
	const SetOfString &builtinElements() const;	/* transient */	/* not serialized */
	const SetOfString &builtinAttributes() const;	/* transient */	/* not serialized */
	friend ostream &operator<<(ostream &_param_113, const wsdl__definitions &_param_114);	/* transient */
	friend istream &operator>>(istream &_param_115, wsdl__definitions &_param_116);	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_wsdl__definitions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (390)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (391)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (393)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (394)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (395)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (8)
typedef char *xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef char *xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef char *xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (11)
typedef char *xsd__NMTOKEN;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKENS
#define SOAP_TYPE_xsd__NMTOKENS (12)
typedef char *xsd__NMTOKENS;
#endif

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (13)
typedef char *xsd__QName;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (14)
typedef char *xsd__string;
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (16)
typedef bool xsd__boolean;
#endif

#ifndef SOAP_TYPE_xs__namespaceList
#define SOAP_TYPE_xs__namespaceList (73)
typedef char *xs__namespaceList;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


extern ostream &operator<<(ostream &o, const xs__schema &e);

extern istream &operator>>(istream &i, xs__schema &e);

extern ostream &operator<<(ostream &o, const wsdl__definitions &e);

extern istream &operator>>(istream &i, wsdl__definitions &e);

#endif

/* End of wsdlStub.h */
