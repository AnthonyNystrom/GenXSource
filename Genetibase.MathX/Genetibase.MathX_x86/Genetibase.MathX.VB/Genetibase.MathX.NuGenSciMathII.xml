<?xml version="1.0"?>
<!--Generated by AxTools CodeSMART 2005 for VS.NET on 12/2/2005 11:25:24 AM-->
<doc>
  <assembly>
    <name>Genetibase.MathX.NuGenSciMathII</name>
  </assembly>
  <members>
    <!--The members collection-->
    <member name="M:Genetibase.MathX.NuGenFunctionPlotting.FunctionPlot.ThreeDGridPlot">
            <summary> 3-D grid plot </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenBinary">
    <summary> Logical Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.BinaryAddition(System.String@,System.String@)">
        <summary> Binary Addition </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_Not(System.String@)">
        <summary> Binary Not </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_And(System.String@,System.String@)">
        <summary> Binary And </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_Or(System.String@,System.String@)">
        <summary> Binary Or </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_Xor(System.String@,System.String@)">
        <summary> Binary Xor </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_Nand(System.String@,System.String@)">
        <summary> Binary Nand </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_Nor(System.String@,System.String@)">
        <summary> Binary Nor </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.Binary_NXor(System.String@,System.String@)">
        <summary> Binary NXor </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.DecimalToBinary(System.Object@)">
        <summary> Decimal To Binary </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.BinaryToDecimal(System.String@)">
        <summary> Binary To Decimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.HexadecimalToDecimal(System.String@)">
        <summary> Hexadecimal To Decimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.DecimalToHexadecimal(System.Object@)">
        <summary> Decimal To Hexadecimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.HexadecimalToBinary(System.String@)">
        <summary> Hexadecimal To Binary </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.BinaryToHexadecimal(System.String@)">
        <summary> Binary To Hexadecimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenBinary.SetBinaryValue(System.String@)">
        <summary> Set Binary Value </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions">
   <summary>Hyperbolic Trigonometric Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HSin(System.Double)">
        <summary>Hyperbolic Sine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HCos(System.Double)">
        <summary> Hyperbolic Cosine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HTan(System.Double)">
        <summary> Hyperbolic Tangent </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HSec(System.Double)">
        <summary> Hyperbolic Secant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HCosec(System.Double)">
        <summary> Hyperbolic Cosecant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HCotan(System.Double)">
        <summary> Hyperbolic Cotangent </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArcsin(System.Double)">
        <summary> Inverse Hyperbolic Sine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArccos(System.Double)">
        <summary> Inverse Hyperbolic Cosine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArctan(System.Double)">
        <summary> Inverse Hyperbolic Tangent </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArcsec(System.Double)">
        <summary> Inverse Hyperbolic Secant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArccosec(System.Double)">
        <summary> Inverse Hyperbolic Cosecant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenHyperbolicTrigonometricFunctions.HArccotan(System.Double)">
        <summary> Inverse Hyperbolic Cotangent </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenLogaritmicFunctions">
    <summary> Logarithmic and Other Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLogaritmicFunctions.Lg(System.Double@)">
        <summary> Logarithm </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLogaritmicFunctions.LogN(System.Double,System.Double)">
        <summary> Logarithm to base N </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLogaritmicFunctions.Factorial(System.Int32@)">
        <summary> Factorial </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenRoots">
    <summary> Find roots </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenRoots.F(System.Decimal@,System.Decimal@,System.Decimal@)">
        <summary> Function </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenRoots.FindRoots(System.Decimal@,System.Decimal@)">
        <summary> Find roots </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenTrigonometricFunctions">
    <summary> Trigonometric Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Sec(System.Double)">
        <summary> Secant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Cosec(System.Double)">
        <summary> Cosecant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Cotan(System.Double)">
        <summary> Cotangent </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Arcsin(System.Double)">
        <summary> Inverse Sine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Arccos(System.Double)">
        <summary> Inverse Cosine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Arcsec(System.Double)">
        <summary> Inverse Secant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Arccosec(System.Double)">
        <summary> Inverse Cosecant </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometricFunctions.Arccotan(System.Double)">
        <summary> Inverse Cotangent </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenGauss">
    <summary> This is Algorithm of Gauss Eliminations
   
    a as integer => Ad(a,a)   Ed(a) => X(a)=Elimination(a)
    
    Ad |3  1   5|     X| ? |     Ed| 5 |
       |2  3   4| *    | ? |   =   | 2 |
       |2  5   8|      | ? |       | 6 |
    
    or a = something
    
    Ad |3  1   5   2|     X| ? |     Ed| 5 |
       |2  3   4   5| *    | ? |   =   | 2 |
       |2  5   8   4|      | ? |       | 6 |
       |2  3   4   8|      | ? |       | 4 |
       
       In FuncTion or Sub
    
       Matris as New Gauss()
       and Then a as integer ' matris row , colon number
       A(,)    two dimension Array =>  A(a,a) as double
       E()     a dimension Array   =>  E(a) as double
       X()     a dimension Array   =>  X(a) as double
       a=3 =>
       A(0,0)=3    :   A(0,1)=1    :   A(0,2)=5        
       A(1,0)=2    :   A(1,1)=3    :   A(1,2)=4        
       A(2,0)=2    :   A(2,1)=5    :   A(2,2)=8
    
       E(0)=5      :   E(1)=2      :   E(2)=6
    
       X=matris.ellimination(A,E)
       X(0)=-0,5   :   X(1)=-1,0   :   X(2)=1,5 
    </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenGauss.Elimination(System.Double[0:,0:],System.Double[])">
        <summary> Gauss Elimination </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenLinearRegression">
    <summary> Linear Regression </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLinearRegression.LRegress(System.Double[]@,System.Double[]@)">
        <summary> Linear Regression </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenLinearSystemSolver">
    <summary>Solves the linear equation system [A]{x}={b} for {x}
    and calculates the determinant of matrix [A] 
    </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLinearSystemSolver.SOLVE(System.Decimal[0:,0:],System.Decimal[],System.Int32)">
        <summary> Solves the linear equation </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLinearSystemSolver.Build_Triangular_Matrix">
        <summary> Builds Triangular Matrix </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenLinearSystemSolver.Back_Substitution">
        <summary> Calculates the Solution array {x} using back substitution </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenDistributions">
    <summary> Numerical computation of special distributions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.LINEAR(System.Decimal,System.Decimal,System.Int32@,System.Decimal@)">
        <summary> [42900] Linear random number generator (LINEAR) 
        U=mean, V=spread, D=seed
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.NORMAL(System.Decimal,System.Decimal,System.Decimal@)">
        <summary> [42925] Normal distribution by central limit theorem (NORMAL) 
        U=mean, V=standard deviation, E=random no. generated
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.POISSON(System.Decimal,System.Decimal@)">
        <summary> [42950] Poisson random number generator (POISSON) 
        Input parameter U
       </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.BINOMIAL(System.Decimal,System.Int32,System.Decimal@)">
        <summary> [42975] Binomial random number generator (BINOMIAL)
        B=probability per trial, N=number of trials
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.EXPONENT(System.Decimal,System.Decimal)">
        <summary> [43000] Exponential random number generator (EXPONENT)
        U=mean
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.FERMI(System.Decimal,System.Decimal,System.Decimal@)">
        <summary> [43025] Fermi random number generator (FERMI)
        U=inflection point, V=spread of transition region
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.CAUCHY(System.Decimal,System.Decimal@)">
        <summary> [43050] Cauchy random number generator (CAUCHY)
        U=mean
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.GAMMA(System.Decimal,System.Decimal@)">
        <summary> [43075] Gamma (N=2) random number generator (GAMMA)
        B=input parameter
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.BETA(System.Int32,System.Decimal,System.Decimal@)">
        <summary> [43100] Beta random number generator (BETA)
        Input parameters are A and B
        A is restricted to A=1 and A=2
        Guard against divide by zero
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenDistributions.WEIBULL(System.Decimal,System.Decimal,System.Decimal@)">
        <summary> [43150] Weibull random number genrator (WEIBULL)
        Input parameters are U and V
        </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenMatrixOperations">
    <summary> Vector and matrix operations </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.InitMatrix(System.Int32,System.Int32,System.Decimal[])">
        <summary> Initialize a matrix from one dimensional array </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTADD(System.Int32,System.Decimal[],System.Decimal[],System.Decimal[]@)">
        <summary> [41500] Vector addition subroutine (C=A+B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTSUB(System.Int32,System.Decimal[],System.Decimal[],System.Decimal[]@)">
        <summary> [41550] Vector substraction subroutine (C=A-B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTDOT(System.Int32,System.Decimal[],System.Decimal[],System.Decimal@)">
        <summary> [41600] Vector dot product subroutine (C=A.B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTCURL(System.Int32,System.Decimal[],System.Decimal[],System.Decimal[]@)">
        <summary> [41650] Vector cross product subroutine (C=A X B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTLEN(System.Int32,System.Decimal[],System.Decimal@)">
        <summary> [41700] Vector length subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.VECTANGL(System.Int32,System.Decimal[],System.Decimal[],System.Decimal@)">
        <summary> [41750] Vector angle subroutine ( angle between A and B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATADD(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [41800] Matrix addition subroutine (C=A+B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATADD(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:])">
        <summary> Matrix addition function (C=A+B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATSUB(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [41850] Matrix substraction subroutine (C=A-B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATMULT(System.Int32,System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [41900] Matrix multiplication subroutine (C=A X B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATTRANS(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [41950] Matrix transpose subroutine (B=transpose(A)) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATDIAG(System.Int32,System.Decimal,System.Decimal[0:,0:]@)">
        <summary> [42000] Diagonal matrix creation subroutine (matrix A(i,j) is the identity matrix times B) </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATSAV(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [42100] Matrix save subroutine
        N1, N2 are input indices
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATSCALE(System.Int32,System.Int32,System.Decimal,System.Decimal[0:,0:]@)">
        <summary> [42200] Scalar B X matrix A subroutine
        N1, N2 and N3 are input indices
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATSWCH(System.Int32,System.Int32,System.Int32,System.Decimal[0:,0:]@)">
        <summary> [42250] Row switching subroutine
        Rows N1 and N2 are interchanged
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATRMAD(System.Int32,System.Int32,System.Int32,System.Decimal,System.Decimal[0:,0:]@)">
        <summary> [42275] Row multiplication/add subroutine 
        B times row N1 added to N2
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATCOFAT(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> [42300] Cofactor K subroutine
        Input matrix size is N X N
        Matrix A(i,j) IN, matrix B(i,j) OUT
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATDET(System.Int32,System.Decimal[0:,0:])">
        <summary> [42350] Matrix determinant subroutine 
        Finds determinant for up to a 4 X 4 matrix
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.ThirdOrderDet(System.Decimal[0:,0:])">
        <summary> [42363] Third order determinant function </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATINV(System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
        <summary> Matrix inversion subroutine (Gauss-Jordan elimination)
        Matrix A is input, matrix B is output
        Dim A=N X N temporary Dim B=N X 2N
        First create matrix with A on the left and I on the right
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.EIGENPOW(System.Int32,System.Decimal[0:,0:],System.Decimal,System.Int32,System.Decimal[0:,0:]@,System.Decimal@,System.Int32@)">
        <summary> [42700] Eigenvalue (power method) subroutine (AX=LX)
        A is the N X N matrix
        B is an arbitrary vector
        E is the relative error chosen
        D=count of the number of iterations
        </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenMatrixOperations.MATEXP(System.Int32,System.Decimal[0:,0:],System.Int32,System.Decimal,System.Decimal[0:,0:]@)">
        <summary> [42800] Matrix exponent subroutine
        Inputs to the subroutine are the matrix A, matrix C, size N, number of terms K2 and variable X
        </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenSystemsOfCoordinates">
    <summary> Systems of Coordinates </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.RECTPOL(System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
        <summary> [40400] Rectangular to Polar conversion </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.POLRECT(System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
        <summary> [40450] Polar to Rectangular conversion </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZADD(System.Decimal[]@,System.Decimal[]@)">
        <summary> [40300] Complex number addition </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZSUB(System.Decimal[]@,System.Decimal[]@)">
        <summary> [40350] Complex number subtraction </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZPOLMLT(System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@)">
        <summary> [40500] Polar multiplication </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZPOLDIV(System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@)">
        <summary> [40550] Polar division </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZRECTMLT(System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@)">
        <summary> [40600] Rectangular complex number multiplication </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZRECTDIV(System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@)">
        <summary> [40800] Rectangular complex number division </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZPOLPOW(System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
        <summary> [41100] Polar power </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZPOLRT(System.Int32,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
        <summary> [41150] Polar (first) root </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZRECTPOW(System.Int32,System.Decimal@,System.Decimal@)">
        <summary> [41200] Rectangular complex number power </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.ZRECTRT(System.Int32,System.Int32,System.Decimal@,System.Decimal@)">
        <summary> [41300] Rectangular complex number root </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.SPRRECT(System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Decimal@)">
        <summary> [41400] Spherical to Rectangular (cartesian) conversion </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSystemsOfCoordinates.RECTSPR(System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Decimal@)">
        <summary> [41450] Rectangular (cartesian) to Spherical conversion </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenTrigFunctions">
    <summary> Trigonometric functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.SINE(System.Decimal)">
        <summary> [43210] Sine series </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.COSINE(System.Decimal)">
        <summary> [43225] Cosine series </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.ARCTAN(System.Decimal)">
        <summary> [43245] Arctangent series subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.LNX(System.Decimal)">
        <summary> [43280] Natural logarithm series subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.EXPX(System.Decimal)">
        <summary> [43470] Exponent series subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.LOGX(System.Decimal)">
        <summary> [43260] Log base ten series subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.TENPOW(System.Decimal)">
        <summary> [43450] Power of ten series subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.SERSUM(System.Int32,System.Decimal[],System.Decimal,System.Decimal@)">
        <summary> [43200] Series summation subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.SINDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43300] Sine series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.COSDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43310] Cosine series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.ARCDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43320] Arctangent series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.LOGDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43340] Log base ten series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.LNDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43360] Natural logarithm series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.EXPDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43380] Power of e series coefficients </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigFunctions.TENDATA(System.Int32@,System.Decimal[]@)">
        <summary> [43400] Power of ten series coefficients </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenComplexLib">
    <summary> Complex Number Operations </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.Imaginary">
        <summary> The imaginary part of the complex number </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.Real">
        <summary> The real part of the complex number </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.Magnitude">
        <summary> The magnitude of the complex number </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.Theta">
        <summary> If Theta is entered directly through this property, the number is assumed to be in radians </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.Conjugate">
        <summary> The conjugate of the complex number </summary>
</member>
    <member name="P:Genetibase.MathX.NuGenComplexLib.CNError">
        <summary> The error code </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.ChgSign">
        <summary> Changes the sign of a complex number </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Invert">
        <summary> Inverts the complex number </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Exp(System.Int32@)">
        <summary> Raises the complex number to the indicated power using De Moivre's Theorem </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.ExtractRoots(System.Int32@)">
        <summary> Routine to extract the roots of a complex number using De Moivre's Theorem </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Divide(Genetibase.MathX.NuGenComplexLib@)">
        <summary> Routine to divide two complex numbers </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Multiply(Genetibase.MathX.NuGenComplexLib@)">
        <summary> Routine to multiply two complex numbers </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Subtract(Genetibase.MathX.NuGenComplexLib@)">
        <summary> Routine to subtract two complex numbers </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.Add(Genetibase.MathX.NuGenComplexLib@)">
        <summary> Routine to add two complex numbers </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.GetRectangular">
        <summary> Calculate the rectangular coordinates- given the polar coordinates </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.GetPolar">
        <summary> Calculate polar coordinates </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.#ctor">
        <summary> Initialize a new instance of this class </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.cplxNumToString(System.Boolean@,System.Boolean@,System.Int32@)">
        <summary> Returns the string representation </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenComplexLib.stringToCplxNum(System.String@,System.Boolean@)">
        <summary> Returns the NuGenComplexLib representation </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NuGenComplexLib.RemoveWhitespace(System.String@)"-->
    <member name="T:Genetibase.MathX.NuGenErrorLib">
    <summary> The error class </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1">
        <summary> Equation Roots </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.SUBROUTINE_2(System.Decimal,System.Decimal@)">
            <summary> Function subroutines </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.BISECT(System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Bisection method subroutine 
            This program iteratively seeks the zero
            of a function using the method of interval
            halving until the interval is less than
            E in width.
            It is assumed that the function Y=Y(X)
            is available from the function subroutine
            located at 44300.
            This subroutine requires as input the initial
            range values (X0 and X1), as well as the
            convergence criterion, e.
            The zero must be within the range specified
            or an erroneous value will be returned in X.
            this subroutine returns the estimate of the root
            In X, and the corresponding y value.
            Also returned is the number of steps (M).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.ZNEWTON(System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Newton's method subroutine 
            This program calculates the zeros of a
            function by newton's method.
            The routine requires an initial guess, X0,
            and a convergence factor, E.
            Also required is a limit on the number
            of iterations, M. The number used is
            returned in N.
            It is assumed that the function and its
            derivative are in the subroutine at 44300.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.SECANT(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Secant method subroutine 
            This subroutine calculates the zeroes of a
            function using the secant method.
            Two initial guesses are required, X0 and X1.
            the convergence criterion is E.
            The maximum number of iterations is M.
            The number of iterations performed is
            returned in N.
            The result is returned in X.
            The function = Y(X)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.REGULA(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Modified false position subroutine 
            Subroutine uses hamming's modification to
            speed convergence.
            The function = Y(X)
            The two intitial guesses are X0 and X1.
            these two guesses must bracket the zero.
            the convergence criterion is E.
            The maximum number of guesses is M.
            The result is returned in X.
            The number of iterations is returned in N.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.AITKEN(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Aitken acceleration subroutine 
            This routine calculates the zeros of a function
            by iteration, and employs aitken acceleration to
            speed up convergence.
            The subroutine requires an initial guess, X0,
            and two convergence factors, C and E.
            E relates to the accuracy of the estimate, and C
            is used to aid the convergence.
            Also required is an iteration limit, M.
            C=-1 is a normal value. If divergence occurs,
            smaller and/or positive values should be tried.
            The result is returned in X.
            The number of iterations is returned in N.
            The function = Y(X)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.ASITER(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Aitken-steffenson iteration subroutine 
            This routine calculates the zeros of a function
            by iteration, and employs aitken acceleration to
            speed up convergence.
            The subroutine requires an initial guess, X0,
            and two convergence factors, C and E.
            E relates to the accuracy of the estimate, and C
            is used to aid the convergence.
            Also required is a limit to the number of iterations, M.
            C=-1 is a normal value. If divergence occurs,
            smaller and/or positive values should be tried.
            The result is returned in X.
            The number of iterations is returned in N.
            The function = Y(X)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.RSYNDIV(System.Int32,System.Int32,System.Decimal[],System.Decimal[],System.Decimal[]@)">
            <summary> Synthetic division subroutine 
            Assumes real polynomial coefficients.
            Form calculated is A(X)=C(X)/B(X).
            The input polynomial coefficients are
            C(I) and B(I), the result is A(I).
            C(x) is of order N1, B(X) is of order N2.
            Result is of order N1-N2 (at most).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots1.NEXTROOT(System.Decimal,System.Decimal,System.Int32,System.Int32,System.Decimal[],System.Decimal@,System.Int32@)">
            <summary> Subroutine for determining additional roots of a function given a set of already established roots 
            Use is restricted to real roots.
            Method applied is newton-raphson iteration.
            The L established roots are A(I).
            The function Y and its derivative are placed in subroutine 44300.
            The initial guess is X0.
            The accuracy criteria is E.
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2">
        <summary> Equation Roots </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.SUBROUTINE_1_2_6_7(System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
            <summary> Function subroutines </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.ROOTNUM(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,System.Decimal@)"-->
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.ZCIRCLE(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Int32,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Complex root search subroutine 
            This program searches for the complex roots
            of an analytical function by encircling the
            zero and estimating where it is. The circle
            is subsequently tightened by a factor E, and
            a new estimate made.
            The inputs to the subroutine are
             (X0,Y0) - the initial guesses
             W - the initial radius of the search circle
             E - the factor by which the circle is reduced
             N - the number of iterations
             M - the number of evaluation points per quadrant
            the results is returned in Z=X+IY (X,Y).
            Also, the number of iterations performed, or
            in progress, is returned in K.
            X(I),Y(I),U(I) and V(I) must be dimensioned
            in the calling program to 4M.
            It is assumed that the function is decomposed
            into its real and imaginary parts, U(X,Y) and
            V(X,Y), and that these are accessible by a call
            to the function subroutine which returns U and V.
            Start calculation by finding the evaluation points
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.AUXILLIARY_SUBROUTINE(System.Int32,System.Int32@,System.Int32@)">
            <summary> Auxilliary subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.AUXILLIARY_SUBROUTINE_INTERPOLATION(System.Int32,System.Int32,System.Decimal[],System.Decimal[],System.Decimal[],System.Decimal[],System.Int32@,System.Decimal@,System.Decimal@)">
            <summary> Auxilliary subroutine for interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.CZNEWTON(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Complex root seeking using newton's method 
            This routine uses the complex domain form of
            newton's method for iteratively searching for roots.
            It is assumed that the function and its first partial
            derivatives are available from the functions subroutine
            in the form  F(Z) = u(X,Y) + i V(X,Y).
            The required derivatives are dU/dX and dU/dY.
            The inputs to the subroutine are the initial guess, X0, Y0,
            the convergence criteria, E, and the maximum number of
            iterations to be performed, N.
            The resulting approximation to the root is returned in
            (X,Y), and the number of iterations in K.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.MUELLER(System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> Parabolic root seeking subroutine 
            This program iteratively seeks the root of a
            function by fitting a parabola to three points
            and calculating the nearest root as described in
            becket and hurt, numerical calculations and algorithms.
            The subroutine inputs are
                X0 - the initial guess
                D - a bound on the error in this guess
                E - the convergence criteria
                N - the maximum number of iterations
            The program returns the value of the root found, X,
            and the number of iterations performed, K.
            it is assumed that the function Y(X) is available
            in the functions subroutine.
            Set up the three evaluation points
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.MUELLER2(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Parabolic root seeking subroutine 
            This program iteratively seeks the root of a
            function by fitting a parabola to three points
            and calculating the nearest root as described in
            becket and hurt, numerical calculations and algorithms.
            the subroutine inputs are
                X0,Y0 - the initial guess
                B1,B2 - a bound on the error in this guess
                E - the convergence criteria
                N - the maximum number of iterations
            the program returns the value of the root found, (X,Y),
            and the number of iterations performed, K.
            It is assumed that the function U(X,Y) is available
            in the functions subroutine.
            Set up the three evaluation points
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.UTILITY_SUBROUTINE(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal@)">
            <summary> Utility subroutine  </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.ZMUELLER(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Mueller's method for complex roots 
            This program uses the parabolic fitting technique
            associated with Mueller's method, but does it in
            the complex domain.
            The inputs to the subroutine are the initial
            guess, (X0,Y0), the convergence criteria, E,
            and the maximum number of iterations, N.
            Also required are bounds on the initial guess, B1 and B2.
            returned is the new estimate, (X,Y), and the
            number of iterations performed, K.
            It is assumed that the function F(Z) = U(X,Y)+IV(X,Y)
            Is available in the functions subroutine.
            Start calculations
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.ALLROOT(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Int32,System.Int32,System.Int32,System.Decimal[]@,System.Decimal[]@,System.Int32@)">
            <summary> General root determination subroutine 
            The routine attempts to calculate the several roots of a
            given series or function by repeatedly using the
            Zmueller subroutine and 'oving the roots already found
            by division.
            The input to the subroutine are
                X0,Y0 - the initial guess
                B1,B2 - the bounds on this guess
                E - the convergence criteria
                N - the maximum number of iterations per root
                N2 - the number of roots being sought
                N3 - a flag indicating a function F(Z) (1)
                     Or a polynomial (2)
            The program returns the n2 roots found, X(I),Y(I)
            and the last number of iterations used, K.
            If K=0 then N3 was in error
            start calculations
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.COEFFICIENTS_SUBROUTINE(System.Int32@,System.Decimal[]@)">
            <summary> Coefficients subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.VARIANT_MUELLER(System.Int32,System.Decimal,System.Decimal,System.Int32,System.Decimal[],System.Int32,System.Int32,System.Decimal[],System.Decimal[],System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Variant on mueller's method for complex roots
            This program uses the parabolic fitting technique
            associated with Mueller's method, but does it in
            the complex domain.
            The inputs to the subroutine are the initial
            guess, (X0,Y0), the convergence criteria, E,
            and the maximum number of iterations, N.
            Also required are bounds on the initial guess, B1 and B2.
            Returned is the new estimate, (X,Y), and the
            number of iterations performed, K.
            It is assumed that the function F(Z) = U(X,Y)+IV(X,Y)
            is available in the functions subroutine.
            Start calculations
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.SUPERVISOR_SUBROUTINE(System.Int32,System.Int32,System.Decimal[],System.Decimal[],System.Decimal[],System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@)">
            <summary> Supervisor subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.QUADRAT(System.Decimal[],System.Decimal@,System.Decimal@,System.Decimal@,System.Decimal@)">
            <summary> Quadratic root subroutine
            This program calculates the two roots of
            a given second order polynomial using
            the quadratic equation evaluated in a
            manner which minimizes round off error.
            The polynomial is assumed to be of
            the form
                 Y = A(2)*X*X +A(1)*X +A(0)
            The two roots are returned as 
            R1 = X1 + I Y1
            R2 = X2 + I Y2
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.LIN(System.Int32,System.Decimal[],System.Decimal,System.Int32,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Polynomial complex roots subroutine
            uses Lin's method as described in the reference
            a practical guide to computer methods for engineers by shoup.
            The input polynomial coefficients are A(0) through A(M).
            M is the order of the polynomial.
            Initial guesses for A and B are required.
            The results are returned in X1,Y1 and X2,Y2.
            X is the real part, and Y is the imaginary.
            The maxinum number of iterations is N.
            The number of iterations is returned in K.
            The convergence criterion is E.
            If necessary, dimension A(I), B(I) and C(I) in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenEquationRoots2.BAIRSTOW(System.Int32,System.Decimal[],System.Decimal,System.Int32,System.Decimal,System.Decimal,System.Decimal@,System.Decimal@,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Bairstow complex root subroutine
            This subroutine finds the complex conjugate roots
            of a polynomial having real coefficients.
            See computer methods for science and engineering
            by R.L. Lafara.
            order of input series is M >= 4.
            Series coefficients are A(I).
            Initial guesses A and B are required.
            E is the convergence factor.
            Subroutine returns X1,Y1 and X2,Y2.
            N is the maximum number of iterations.
            K is the number of iterations performed.
            If necessary, dimension A(I),B(I), C(I) and D(I)
            in the calling program.
            Use normalized series, C(I)
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation">
        <summary> Function Aproximations </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.MATMULT(System.Int32,System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
            <summary> Matrix multiplication subroutine 
            C=A X B   A is M1 by N1   B is M2 by N2   C is M1 by N2
            N1 = M2
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.MATTRANS(System.Int32,System.Int32,System.Decimal[0:,0:],System.Decimal[0:,0:]@)">
            <summary> Matrix transpose subroutine 
            B=TRANSPOSE(A)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.LSTSQR1(System.Int32,System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@,System.Decimal@)">
            <summary> Linear least squares subroutine
            The input data set is (X(M),Y(M)).
            The number of data points is N.
            The number of different points must be greater than one.
            X(M) and Y(M) must be dimensioned in the calling program.
            The subroutine also calculates the unbiased estimate
            of the standard deviation, D.
            The returned parameters are A,B and D.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.LSTSQR2(System.Int32,System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@,System.Decimal@,System.Decimal@)">
            <summary> Parabolic least squares subroutine 
            The input data set is (X(M),Y(M)).
            The number of data points is N.
            The number of different points must be greater than three.
            X(M) and Y(M) must be dimensioned in the calling program.
            The subroutine also calculates the unbiased estimate
            of the standard deviation, D.
            The returned parameters are A,B,C and D.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.POLYCM(System.Int32,System.Int32,System.Decimal[],System.Decimal[0:,0:]@)">
            <summary> Coefficient matrix generation subroutine for the one dimensional polynomial regression 
            The input data set consists of N pairs of
            (X(I),Y(I)) values.
            The regression order is N.
            The matrix returned, Z, is M rows by N+1 columns.
            Dimension this matrix in the calling program.
            Recall that the regression routine input will use N+1,.
            You must set N to N+1 before entering it.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.LEASTSQR(System.Int32,System.Int32,System.Decimal[],System.Decimal[0:,0:],System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[]@)">
            <summary> Least squares fitting subroutine 
            General subroutine for multidimensional,
            nonlinear regression.
            The equation fitted has the form
            Y=D(1)X1 + D(2)X2 +  ... + D(N)XN
            Change in notation is due to a dimension conflict.
            The coefficients are returned by the program in D(I).
            The XI can be simple powers of X, or functions.
            Note that the XI are assumed to be independent.
            The measured responses are Y(I)- there are m of them.
            Y is M row column vector, and Z(I,J) is a
            M row by N column matrix.
            M>=N
            The subroutine inputs are Y(I), Z(I,J), M and N.
            The working matrices within the program are A(I,J),
            B(I,J) and C(I,J).
            The subroutine calls several other matrix operation
            routines to perform the calculation.
            Dimension A,B,C,Y and Z in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.Sigma(System.Int32,System.Int32,System.Decimal[],System.Decimal[],System.Decimal[],System.Decimal@)">
            <summary> Standard deviation subroutine 
            This subroutine calculates the standard
            deviation for a polynomial fit.
            The inputs are the number of data points, M,
            The degree of the fit, N,
            The polynomial coefficients, D(I),
            The original data set, X(I), Y(I).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.MLTNLREG(System.Int32,System.Int32,System.Int32[],System.Decimal[0:,0:],System.Decimal[],System.Decimal[]@,System.Decimal[0:,0:]@,System.Decimal@)">
            <summary> Coefficient matrix generation subroutine for multiple nonlinear regression 
            Also calculates the standard deviation, D, even
            though there is some redundant computing.
            The maximum number of dimensions is 9.
            The input data set consists of m data sets of the form
                 Y(I), X(I,1), X(I,2),......, X(I,L)
            The number of dimensions is L.
            The order of the fit to each dimension is M(J).
            The result is an (M1+1)*(M2+1)...*(ML+1)+1
            column by M row matrix, Z.
            This matrix is arranged as follows ( example- L=2, M(1)=2, M(2)=2)
              1  X1  X1*X1  X2  X2*X1  X2*X1*X1  X2*X2  X2*X2*X1  X2*X2*X1*X1
            This matrix should be dimensioned in the calling program
            as should also the X(A,J) matrix of data values.
            Calculate the total number of dimensions
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.LSQRPOLY(System.Int32,System.Decimal,System.Int32,System.Decimal[],System.Decimal[],System.Decimal[]@,System.Decimal@,System.Int32@)">
            <summary> Least squares polynomial fitting subroutine 
            This program least squares fits a polynomial to input data.
            forsythe orthogonal polynomials are used in the fitting.
            The number of data points is N.
            The data is input to the subroutine in X(I),Y(I) pairs.
            The coefficients are returned in C(I).
            The smoothed data is returned in V(I).
            The order of the fit is specified by M.
            The standard deviation of the fit is returned in D.
            There are two options available by use of the parameter E.
            If E=0 the fit is to order M.
            If E>0 the order of fit increases towards M, but 
            will stop if the relative standard deviation does not 
            decrease by more than E between successive fits.
            The order of the fit then obtained is L.
            The arrays X,Y,V,A,B,C,C2,D,E and F Must be dimensioned.
            A(I) and B(I) are simply work arrays
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.REGITER(System.Int32,System.Int32,System.Int32,System.Int32[],System.Decimal[0:,0:],System.Decimal[],System.Decimal[]@,System.Decimal@,System.Int32@)">
            <summary> Multi-dimensional polynomial regression iteration subroutine 
            This program supervises the calling of several
            other subroutines in order to iteratively
            fit least squares polynomials in more than
            one dimension.
            The program repeatedly calculates improved coefficients
            until the standard deviation is no longer reduced.
            The inputs to the subroutine are the number of
            dimensions, L, the degree of fit for each
            dimension, M(I), and the input data, X(I,J) and Y(I).
            The coefficients are returned in D(I), with the
            standard deviation in D.
            Also returned is the number of iterations tried, L1.
            The original Y(I) values are saved in Y1(I).
            The current coefficients are stored in D1(I).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.PARAFIT(System.Int32,System.Int32,System.Decimal,System.Decimal,System.Int32[]@,System.Decimal[]@,System.Decimal[]@,System.Decimal@,System.Int32@)">
            <summary> Parametric least squares curve fit subroutine 
            This program least squares fits a function to a set of
            data values by successively (parameter by parameter) reducing the variance.
            Convergence depends on the initial values.- convergence is not assured.
            N pairs of data values, (X(I),Y(I)), are given.
            There are L parameters, A(J), to be optimized across.
            Required are initial values for the parameter A(L) and E.
            Another important parameter which affects stability is E1,
            Which is initially converted to E1(L) for the first intervals.
            the parameters are multiplied by (1-E1(I)) on each pass.
            Dimension X(I),Y(I),A(I) and E1(I) in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation._44286(System.Int32,System.Int32,System.Int32[]@,System.Decimal[]@,System.Decimal[]@,System.Decimal@,System.Decimal@)">
            <summary> Residual generation subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation._44300(System.Decimal[]@,System.Int32)">
            <summary> Functions subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenFunctionApproximation.CHISQA(System.Int32,System.Decimal,System.Decimal@)">
            <summary> Chi-square cummulative distribution approximation 
            Reference- statistics manual
            crow, maxfield and davis (dover, 1960).
            the input value is Y, the probability.
            The output value is the corresponding
            chi-square statistic.
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1">
        <summary> Interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.NTHROOT(System.Int32,System.Int32,System.Decimal,System.Int32,System.Decimal@,System.Int32@)">
            <summary> NTH root subroutine 
            Uses newton-raphson iteration.
            Reference- hart, computer approximations.
            Exponent is 1/N, input parameter is N
            Note that N Must be an integer.
            Argument is Y, desired accuracy is E.
            Returned value is X.
            Initial value is X0.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.GENROOT(System.Int32,System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal[]@)">
            <summary> General root determination subroutine 
            High accuracy iteration involving the square root.
            Routine decomposes exponent into a binary representation
            and then applies newton-raphson iteration.
            Y is the input, N is the exponent, and X the returned root.
            E is the desired accuracy of the iteration.
            M is the desired number of bits in the representation of N.
            Save Y For returning from subroutine.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.RTDECOMP(System.Int32,System.Decimal,System.Decimal[]@)">
            <summary> Root decomposition subroutine 
            Decompose root n into a binary representation.
            M is the number of binary digits.
            N is the input decimal number.
            N1 is the integer part of N.
            A(I) is the binary representation of the remaining fraction.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.MULTIPLYING_FACTORS(System.Int32,System.Decimal,System.Decimal,System.Decimal,System.Decimal@,System.Decimal[]@,System.Decimal,System.Decimal,System.Int32)">
            <summary> Find multiplying factors </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.SQROOT(System.Decimal,System.Decimal)">
            <summary> Square root subroutine 
            Uses newton-raphson iteration.
            Called Heron's rule.
            Reference- hart, computer approximations.
            Argument is Y, returned value is X1.
            Desired accuracy is E.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.TANITER(System.Decimal,System.Decimal,System.Decimal@)">
            <summary> Tangent iteration subroutine
            Uses the inverse tangent.
            Based on Newton-Raphson iteration.
            X is the argument, Y is the result.
            The desired accuracy is E.
            Note, the allowable range of the argument is -PI/2 TO PI/2.
            Initial guess is X0=1
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.ATANITER(System.Decimal,System.Decimal,System.Decimal@,System.Int32@)">
            <summary> Inverse tangent recursion subroutine
            Uses gauss iteration
            Reference- acton, numerical methods that work
            Argument is X, result is Y
            Desired accuracy is E
            Heron's rule (iteration) for the square root is also used
            A0,A1,B0,B1 are dummy variables
            </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.ARCSINX(System.Decimal,System.Decimal,System.Decimal@,System.Int32@)"-->
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.CLIPTIC(System.Decimal,System.Decimal,System.Decimal[],System.Decimal[],System.Int32@,System.Decimal@,System.Decimal@)">
            <summary> Complete elliptic integral of the first and second kind 
            The input parameter is K, which should
            be between 0 and 1.
            Technique uses Gauss' formula for the
            arithmogeometrical mean.
            Reference- ball, algorithms for RPN calculators.
            E is A measure of the convergence accuracy.
            Depending on E, A(I) and B(I) May have to be dimensioned
            in the calling program.
            The returned values are e1, the elliptic
            integral of the first kind, and E2,
            the integral of the second kind.
            </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.LNX(System.Decimal,System.Decimal,System.Decimal@,System.Int32@)"-->
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.INTBESSL(System.Decimal,System.Decimal,System.Decimal[]@,System.Int32@)">
            <summary> Integer order bessel function subroutine 
            Calculates bessel functions of order 0 through 4
            for X>0.
            Miller's method used, see Henrici
            Argument is X
            Number of steps =M
            Returned results are Y(I)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.LEGNDRE(System.Int32,System.Decimal[0:,0:],System.Decimal[]@)">
            <summary> Legendre series coefficient evaluation subroutine 
            By means of recursion relation
            the order of the polynomial is N
            The coefficients are returned in A(I)
            Dimension A(I) and B(I,J) in the calling program
            Establish P0 and P1 coefficients
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.LAGUERR(System.Int32,System.Decimal[0:,0:],System.Decimal[]@)">
            <summary> Laguerre polynomial coefficient evaluation subroutine
            By means of recursion relation
            the order of the polynomial is N
            The coefficients are returned in A(I)
            Dimension A(I) and B(I,J) in the calling program
            Establish L0 and L1 coefficients
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation1.HERMITE(System.Int32,System.Decimal[0:,0:],System.Decimal[]@)">
            <summary> Hermite polynomial coefficient evaluation subroutine
            BY means of recursion relation
            the order of the polynomial is N
            The coefficients are returned in A(I)
            Dimension A(I) and B(I,J) in the calling program
            Establish H0 and H1 coefficients
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2">
        <summary> Interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.TRIGCORD(System.Decimal[],System.Decimal@,System.Decimal@,System.Decimal@)">
            <summary> Trigonometric cordic subroutine
            This subroutine calculates the sine and cosine
            of an angle using the cordic rotation method.
            The input angle is A.
            The sine is returned in U, and the cosine in V.
            Remember to dimension W(I) and A(I) in the calling program
            If the angle is zero, set functions and return.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.TRIG_CORDIC_WEIGHTS(System.Int32,System.Decimal,System.Decimal,System.Decimal[]@,System.Decimal@)">
            <summary>  Trig cordic weights subroutine
            The weights are W(I)= plus or minus 1
            The input angle is A
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.TRIG_CORDIC_COEFFICIENT(System.Int32@,System.Decimal[]@,System.Decimal@,System.Decimal@)">
            <summary>  Trig cordic coefficient subroutine
            For case N=12
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.INVCORD(System.Decimal[],System.Decimal[],System.Decimal,System.Decimal,System.Decimal,System.Decimal@)">
            <summary> Inverse trigonometric cordic subroutine
            This subroutine calculates the angle corresponding
            to a given sine, cosine or tangent using the
            cordic rotation method.
            The input is U=SIN(A), V=COS(A), or W=TAN(A).
            The returned value is A.
            Ember to dimension W(I) and A(I) in the calling program.
            Translate the U,V,W inputs
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.EXPCORD(System.Decimal,System.Decimal@)">
            <summary>  Modified cordic exponential subroutine
            This program takes an input value and returns Y=EXP(X).
            X may be any positive or negative value.
            Remember to dimension A(I) and W(I) in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.WEIGHT_DETERMINATION(System.Int32,System.Decimal,System.Decimal[]@,System.Decimal@)">
            <summary>  Weight determination subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.EXPONENTIAL_COEFFICIENTS(System.Int32@,System.Decimal@,System.Decimal[]@)">
            <summary> Exponential coefficients subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.LNCORDIC(System.Decimal)">
            <summary> Modified cordic natural logarithm subroutine
            This program takes an input value and returns Y=LN(X).
            X may be any positive value.
            Remember to dimension A(I) and W(I) in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.LNCORDIC_WD(System.Int32,System.Decimal,System.Decimal[],System.Decimal@,System.Decimal[]@)">
            <summary> Weight determination subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.LNCORDIC_EC(System.Int32@,System.Decimal@,System.Decimal[]@)">
            <summary> Exponential coefficients subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.SINH(System.Decimal)">
            <summary> Hyperbolic sine subroutine
            This program uses the definition of the
            hyperbolic sine and the modified cordic
            exponential subroutine to approximate
            ARCSINH(X) over the entire range of real X.
            The input to the subroutine is X.
            The returned value is Y=ARCSINH(X).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.COSH(System.Decimal)">
            <summary> Hyperbolic cosine subroutine
            This program uses the definition of the
            hyperbolic cosine and the modified cordic
            exponential subroutine to approximate
            ARCOSH(X) over the entire range of real X.
            The returned value is Y=ARCOSH(X).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.TANH(System.Decimal)">
            <summary> Hyperbolic tangent subroutine
            This program uses the definition
              TAN(X)=SINH(X)/COSH(X)
            To calculate the hyperbolic tangent.
            The input is X.
            The output is Y=TANH(X).
            Start calculation
            Get SINH(X)
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.INVSINH(System.Decimal)">
            <summary> ARCSINH(X) subroutine
            This routine calculates the inverse
            hyperbolic sine using the modified
            cordic natural logarithm subroutine.
            The input is X.
            The output is Y=ARCSINH(X).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.INVCOSH(System.Decimal)">
            <summary> ARCCOSH(X) subroutine
            This routine calculates the inverse
            hyperbolic cosine using the modified
            cordic natural logarithm subroutine.
            The input is X.
            The output is Y=ARCOSH(X).
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation2.INVTANH(System.Decimal)">
            <summary> ARCTANH(X) subroutine
            This program calculates the inverse
            hyperbolic tangent using the modified
            cordic natural logarithm subroutine.
            The input is X.
            The output is Y=ARCTANH(X).
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3">
        <summary> Interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3.LAGRANGE_INTERPOLATION(System.Decimal@,System.Decimal,System.Decimal[],System.Decimal[],System.Decimal[],System.Decimal,System.Decimal@)">
            <summary> Lagrange interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3.NEWTON_INTERPOLATION(System.Decimal@,System.Decimal,System.Decimal[],System.Decimal[],System.Decimal,System.Decimal@,System.Decimal@)">
            <summary> Newton interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3.AKIMA_SPLINE(System.Decimal,System.Decimal[],System.Decimal[],System.Decimal,System.Decimal@,System.Int32@)">
            <summary> Akima interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3.LAGRANGE_DERIVATIVE_INTERPOLATION(System.Decimal,System.Decimal[],System.Decimal[],System.Int32@,System.Decimal,System.Decimal@)">
            <summary> Lagrange derivative interpolation </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenInterpolation3.GENERAL_INTEGRATION(System.Int32,System.Decimal,System.Decimal,System.Decimal[],System.Decimal[],System.Decimal@,System.Decimal@)">
            <summary> General integration </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives">
        <summary> Numerical Derivatives </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.FUNCTION_SUBROUTINE(System.Decimal[],System.Decimal@,System.Decimal[]@)">
            <summary> Function subroutine </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.STEEPDS(System.Int32,System.Decimal,System.Int32,System.Decimal,System.Decimal[]@,System.Int32@)">
            <summary> Steepest descent optimization subroutine 
            This program find the local maximum or minimum
            of an L-dimensional function using the method
            of steepest descent, or the gradient.
            The function, Y(X(1),X(2)...), is placed in the
            function subroutine, along with the L derivatives
            of F, D(I).
            The routine seeks using an internally adjusted
            multiplier, K. The search is made until an error
            limit, E, is reached.
            The user must supply initial values for the X(I),
            As well as K (initial) and E. The program returns
            the locally optimum X(I) set.
            Remember to dimension X(I) in the calling program.
            The program needs three values of Y to get started.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.MAGNITUDE(System.Int32,System.Decimal,System.Decimal[]@,System.Decimal[]@,System.Decimal[]@,System.Decimal[]@)">
            <summary> Find the magnitude of the gradient </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.STEEPDA(System.Int32,System.Decimal,System.Int32,System.Decimal,System.Decimal[]@,System.Int32@)">
            <summary> Steepest descent optimization subroutine 
            This program find the local maximum or minimum
            of an L-dimensional function using the method
            of steepest descent, or the gradient.
            The function, Y(X(1),X(2)...), is placed in the
            function subroutine. Finite differences are used to
            calculate the L partial derivatives.
            Of F, D(I).
            The routine seeks using an internally adjusted
            multiplier, K. The search is made until an error
            limit, E, is reached.
            The user must supply initial values for the X(I),
            As well as K (initial) and E. The program returns
            the locally optimum X(I) set.
            Remember to dimension X(I) in the calling program.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.MAGNITUDE2(System.Int32,System.Decimal[]@,System.Decimal@)">
            <summary> Find the magnitude of the gradient </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.UpdateX(System.Int32,System.Decimal,System.Decimal,System.Decimal[]@,System.Decimal[]@,System.Decimal[]@,System.Decimal[]@)">
            <summary> Update the X(I) </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalDerivatives.FINITE_DIFFERENCES(System.Int32,System.Decimal,System.Decimal,System.Decimal,System.Decimal[],System.Decimal[],System.Decimal[]@)">
            <summary> Finite differences subroutine for the D(I) approximation
            Look ahead one half interval
            </summary>
</member>
    <member name="T:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries">
        <summary> Numerical Use of Series </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.BESSLSER(System.Int32,System.Decimal,System.Decimal,System.Decimal@,System.Int32@)">
            <summary> Bessel function series subroutine
            The order is N, the argument X.
            The End SubED value is in Y.
            The number of terms used is End SubED in M.
            E is the convergence criterion
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.BESSEL(System.Decimal,System.Int32,System.Decimal[],System.Decimal[])">
            <summary> Bessel function series coefficient evaluation subroutine
            M+1 is the number of coefficients desired.
            N is the order of the bessel function.
            The coefficients are End SubED IN A(I).
            Dimension A(I) and B(I) in the calling program.
            A1,B1 and B(I) are dummy variables.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.BESSEL01(System.Decimal,System.Int32,System.Decimal@,System.Decimal@,System.Int32@,System.Decimal@)">
            <summary> Bessel function asymptotic series subroutine
            This program calculates the zeroth and first order bessel
            functions using an asymptotic series expansion.
            The required input are X and a convergence factor E.
            End SubED are the two bessel functions, J0(X) and J1(X)
            Reference-  algorithms for RPN calculators
              by BALL, J.A.,  WILEY AND SONS,
            CAlculate P and Q polynomials
            P0(X)=M1  P1(X)=M2  Q0(X)=N1  Q1(X)=N2
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.LNX(System.Decimal,System.Decimal@)">
            <summary> Series approximation subroutine for LN(X)
            Accuracy better than 6 places for X>=3.
            Accuracy better than 12 places for X>10.
            Advantage is that very large values of the argument can be used
            without fear of overflow.
            Reference-  CRC math tables.
            X is the input, Y is the output
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.CHI_SQR(System.Int32,System.Decimal,System.Decimal@)">
            <summary> CHI-SQUARE function subroutine
            This program takes a given degree of freedom, M
            and value, X, and calculates the chi-square
            density distribution function value, Y.
            Reference- texas instruments SR-51 owners manual (1974).
            Subroutine LN(X!) is also called.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.CHISQ(System.Int32,System.Decimal,System.Decimal,System.Decimal@)">
            <summary> CHI-SQUARE cummulative distribution 
            The program is fairly accurate and calls upon the
            chi-square probability density function subroutine (chi-sqr).
            The input parameter is M, the number of degrees of freedom.
            Also required is the ordinate value. The program End SubS Y,
            The cummulative distribution integral from 0 to X.
            Reference- Hewlett-Packard statistics programs, 1974.
            This program also requires an accuracy parameter, E, to
            determine the level of summation.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.ASYMERF(System.Int32,System.Decimal@,System.Decimal@,System.Int32@)">
            <summary> Asymptotic series expansion of the integral of 2 exp(-x*x)/sqrt(pi) - the normalized error function
            THis program detemines the values of the above
            integrand using an asymptotic series which is
            evaluated to the level of maximum accuracy.
            The integral is from 0 to X.
            The input parameter is X>0. The results are
            End SubED in Y and Y1, with the error measure in E.
            The program also End SubS the number of terms used.
            NOTE- the error is roughly equal to
            first term neglected in the series summation.
            Reference-  A SHORT TABLE OF INTEGRALS by B.O. PEIRCE
              GINN AND COMPANY   1957
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.CHEBYSER(System.Int32,System.Decimal[0:,0:]@)">
            <summary> Chebychev series coefficient evaluation subroutine
             The order of the polynomial is N.
             The coefficients are End SubED in the
             array B(I,J). I is the degree of the polynomial,
             J is the coefficient order.
             Dimension B(I,J) in the calling program.
             Establish T0 and T1 coefficients
            </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.CHEBECON(System.Int32,System.Int32,System.Int32,System.Decimal[]@,System.Decimal[0:,0:]@,System.Decimal[]@)"-->
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.REVERSE(System.Int32,System.Decimal[],System.Decimal[]@)">
            <summary> Series reversion subroutine 
            This program takes a polynomial, Y=A(0) + A(1)X + ..
            and End SubS a polynomial X = B(0) + B(1)Y + ...
            Reference  CRC STANDARD MATHEMATICAL TABLES
                         24TH EDITION
            The input series coefficients are A(0),A(1), ETC.
            A(1) must be nonzero.
            The output series coefficients are B(0),B(1),....,B(7).
            The degree of reversion is limited to seven.
            A1,A2,.... are dummy variables.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.RECIPRO(System.Int32,System.Int32,System.Decimal[],System.Decimal[]@)">
            <summary> Reciprocal power series subroutine 
            Reference- COMPUTATIONAL ANALYSIS BY HENRICI.
            The input series coefficients are A(I).
            The output series coefficients are B(I).
            The degree of the input polynomial is N..
            The degree of the inverted polynomial is M.
            Dimension A(I) and B(I) in the calling program
            The program will take care of the normalization using L
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.HORNER(System.Decimal,System.Decimal[],System.Decimal[]@,System.Decimal[0:,0:])">
            <summary> Horner's shifting rule subroutine 
            This subroutine takes a given quartic
            polynomial and converts it to a taylor expansion.
            The input series coefficients are A(I).
            The expansion point is X0.
            The shifted coefficients are End SubED in B(I).
            C(4,5) must be dimensioned in the calling program.
            </summary>
</member>
    <!--Badly formed XML comment ignored for member "M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.INVNORM(System.Decimal@,System.Decimal)"-->
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.SINEPROD(System.Decimal,System.Decimal,System.Decimal@,System.Int32@)">
            <summary> Sine product series subroutine 
            This program calculates an approximation to SIN(X)
            Using repeated products.
            The inputs to the program are the argument, X
            and an error factor, E.
            The approximation is returned in Y.
            </summary>
</member>
    <member name="M:Genetibase.MathX.NumericalAnalysis.NuGenNumericalUseOfSeries.CMPLXSER(System.Int32,System.Decimal,System.Decimal,System.Decimal[],System.Decimal@,System.Decimal@)">
            <summary> Complex series evaluation subroutine 
            The series coefficients are A(I), assumed real.
            The order of the polynomial is M.
            The subroutine uses repeated calls to the
            NTH power (Z^N) complex number subroutine.
            Inputs to the subroutine are X,Y,M, and the A(I).
            Outputs are Z1(real) and Z2(imaginary).
            </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenPolynomial">
    <summary> Polynomial Operations </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenPolynomial.Addition(System.Int32,System.Int32,System.Decimal[],System.Decimal[])">
        <summary> Polynomial addition </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenPolynomial.Division(System.Int32,System.Int32,System.Decimal[],System.Decimal[])">
        <summary> Polynomial division </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenPolynomial.Multiplication(System.Int32,System.Int32,System.Decimal[],System.Decimal[])">
        <summary> Polynomial multiplication </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenQuadratic">
    <summary> Quadratic </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenQuadratic.solutionPos">
        <summary> Positive solution </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenQuadratic.solutionNeg">
        <summary> Negative solution </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenSignedLogical">
    <summary> Signed Logical Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryAddition(System.String@,System.String@)">
        <summary> Binary Addition </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinarySubtraction(System.String@,System.String@)">
        <summary> Binary Substraction </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryMultiplication(System.String@,System.String@)">
        <summary> Binary Multiplication </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryIntegerDivision(System.String@,System.String@)">
        <summary> Binary Integer Division </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryModulo(System.String@,System.String@)">
        <summary> Binary Modulo </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryShiftLeft(System.String@)">
        <summary> Binary Shift Left </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryShiftRight(System.String@)">
        <summary> Binary Shift Right </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_Not(System.String@)">
        <summary> Binary Not </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_And(System.String@,System.String@)">
        <summary> Binary And </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_Or(System.String@,System.String@)">
        <summary> Binary Or </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_Xor(System.String@,System.String@)">
        <summary> Binary XOR </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_Nand(System.String@,System.String@)">
        <summary> Binary NAND </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_Nor(System.String@,System.String@)">
        <summary> Binary NOR </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.Binary_NXor(System.String@,System.String@)">
        <summary> Binary NXOR </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryPositiveToNegative(System.String@)">
        <summary> Binary Positive to Negative </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.DecimalToBinary(System.Object@)">
        <summary> Decimal to Binary </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryToDecimal(System.String@)">
        <summary> Binary to Decimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.HexadecimalToDecimal(System.String@)">
        <summary> Hexadecimal to Decimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.DecimalToHexadecimal(System.Object@)">
        <summary> Decimal to Hexadecimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.HexadecimalToBinary(System.String@)">
        <summary> Hexadecimal to Binary </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.BinaryToHexadecimal(System.String@)">
        <summary> Binary to Hexadecimal </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenSignedLogical.SetBinaryValue(System.Object@)">
        <summary> Set Binary Value </summary>
</member>
    <member name="T:Genetibase.MathX.NuGenTrigonometry">
    <summary> Trigonometry Functions </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.ConvertDegreesToRadians(System.Decimal)">
        <summary> Converts the angles in degrees to radians </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.ConvertRadiansToDegrees(System.Decimal)">
        <summary> Converts the angles in radians to degrees </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.HypotenuseFromLengthOpposedAngle(System.Decimal,System.Decimal)">
        <summary> Angles -- input and output in degrees </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.LengthFromHypotenuseOpposedAngle(System.Decimal,System.Decimal)">
        <summary> LengthFromHypotenuseOpposedAngle </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.HypotenuseFromlengthAdjacenteAngle(System.Decimal,System.Decimal)">
        <summary> HypotenuseFromlengthAdjacenteAngle </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.LengthFromHypotenuseAdjacenteAngle(System.Decimal,System.Decimal)">
        <summary> LengthFromHypotenuseAdjacenteAngle </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.LengthFromOpposedAdjacenteAngle(System.Decimal,System.Decimal)">
        <summary> LengthFromOpposedAdjacenteAngle </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.LengthFromOpposedOpposedAngle(System.Decimal,System.Decimal)">
        <summary> LengthFromOpposedOpposedAngle </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.AngleFromLegths(System.Decimal,System.Decimal)">
        <summary> AngleFromLegths </summary>
</member>
    <member name="M:Genetibase.MathX.NuGenTrigonometry.AngleFromHypotenuseOpposed(System.Decimal,System.Decimal)">
        <summary> AngleFromHypotenuseOpposed </summary>
</member>
  </members>
</doc>